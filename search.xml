<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Egg-mongo，基于 MongoDB Native Driver]]></title>
      <url>/2017/07/04/Egg-mongo%EF%BC%8C%E5%9F%BA%E4%BA%8E-MongoDB-Native-Driver/</url>
      <content type="html"><![CDATA[<p>MongoDB 官方为 Node.js 提供了 MongoDB Native Driver。这也是我一直喜欢使用的 MongoDB 库。直接使用官方 API 简单明了，而且也易于学习。</p>
<p>Egg.js 官方提供的 MongoDB 插件基于 Mongoose，所以就自己动手做了这个插件。插件的 API 都是我在实际项目中长期使用的。</p>
<p><strong>GitHub：</strong><a href="https://github.com/brickyang/egg-mongo" target="_blank" rel="noopener">https://github.com/brickyang/egg-mongo</a></p>
<p>本插件基于 <a href="https://github.com/mongodb/node-mongodb-native" target="_blank" rel="noopener">node-mongodb-native</a>，提供了 MongoDB 官方 driver 及 API。</p>
<p>插件对一些常用 API 进行了简单封装以简化使用，同时保留了所有原版属性。例如，使用原版 API 进行一次查找需要写</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">'name'</span>)</span><br><span class="line"> .find(query)</span><br><span class="line"> .skip(skip)</span><br><span class="line"> .limit(limit)</span><br><span class="line"> .project(project)</span><br><span class="line"> .sort(sort)</span><br><span class="line"> .toArray();</span><br></pre></td></tr></table></figure>
<p>封装后</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.mongo.find(<span class="string">'name'</span>, &#123; query, skip, limit, project, sort &#125;);</span><br></pre></td></tr></table></figure>
<p>此插件完全支持 Promise，并强烈推荐使用 async/await。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i egg-mongo-native --save</span><br></pre></td></tr></table></figure>
<h2 id="开启插件"><a href="#开启插件" class="headerlink" title="开启插件"></a>开启插件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/plugin.js</span></span><br><span class="line">exports.mongo = &#123;</span><br><span class="line">  enable: <span class="literal">true</span>,</span><br><span class="line">  package: <span class="string">'egg-mongo'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;app_root&#125;/config/config.default.js</span></span><br><span class="line">exports.mongo = &#123;</span><br><span class="line">  client: &#123;</span><br><span class="line">    host: <span class="string">'localhost'</span>,</span><br><span class="line">    port: <span class="number">27017</span>,</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>请到 <a href="config/config.default.js">config/config.default.js</a> 查看详细配置项说明。</p>
<h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>本插件提供的 API 只是对原版 API 进行了必要的简化，所有属性名称与原版 API 一致。所有针对文档操作的 API，通常接受 2 个参数，第一个参数是 collection 名称，第二个参数是一个对象，属性名即为原版 API 的所有参数。例如，使用原版 API 进行一次插入</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">'name'</span>).insertOne(doc, options);</span><br></pre></td></tr></table></figure>
<p>使用插件 API</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> args = &#123; doc, options &#125;;</span><br><span class="line">app.mongo.insertOne(<span class="string">'name'</span>, args);</span><br></pre></td></tr></table></figure>
<p>可以看到 <code>args</code> 就是包含原版 API 参数的一个对象。</p>
<p>目前插件提供的 API 包括：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">connect()      <span class="comment">// 不需要用户调用</span></span><br><span class="line">insertOne()</span><br><span class="line">findOneAndUpdate()</span><br><span class="line">findOneAndReplace()</span><br><span class="line">findOneAndDelete()</span><br><span class="line">insertMany()</span><br><span class="line">updateMany()</span><br><span class="line">deleteMany()</span><br><span class="line">find()</span><br><span class="line">count()</span><br><span class="line">distinct()</span><br><span class="line">createIndex()</span><br><span class="line">listCollection()</span><br><span class="line">createCollection()</span><br></pre></td></tr></table></figure>
<p>当然，在任何时候你也都可以使用 <code>app.mongo.db</code> 调用所有 API。你可以在这里查看所有 API：<a href="http://mongodb.github.io/node-mongodb-native/2.2/api/" target="_blank" rel="noopener">Node.js MongoDB Driver API</a>。</p>
<h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p><code>node-mongodb-native</code> 所有 API 都支持 Promise，因此你可以自由地以异步或同步方式使用本插件。</p>
<h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  app.mongo.insertOne(<span class="string">'name'</span>, &#123; doc &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 async/await</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> app.mongo.insertOne(<span class="string">'name'</span>, &#123; doc &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Generator</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">create</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">yield</span> app.mongo.insertOne(<span class="string">'name'</span>, &#123; doc &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (errpr) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你使用 <code>app.mongo.db</code> 调用原版 API，则也可以使用回调函数。插件封装的 API 不支持回调函数，因为 Promise 和 async/await 更加优雅。</p>
<p>Node.js 7.6 开始已经原生支持 async/await，不再需要 Babel。</p>
<h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="https://github.com/brickyang/egg-mongo/blob/master/LICENSE" target="_blank" rel="noopener">MIT</a></p>
]]></content>
      
        
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> Egg.js </tag>
            
            <tag> Egg Plugin </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[在 CentOS 7 上安装 Docker]]></title>
      <url>/2017/04/12/%E5%9C%A8-CentOS-7-%E4%B8%8A%E5%AE%89%E8%A3%85-Docker-CE/</url>
      <content type="html"><![CDATA[<p>本文记录在 CentOS 7 服务器上安装 Docker CE 的过程。Docker CE 是社区版，即免费版。Docker EE 是企业版，即收费版。</p>
<p><strong>Docker CE 和 EE 版的安装过程不尽相同，本过程仅适用于 CE 版。</strong></p>
<h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>需要 CentOS 7 64-bit。</p>
<h2 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sudo</span> yum remove docker docker-<span class="meta">common</span> container-<span class="keyword">selinux </span>docker-<span class="keyword">selinux </span>docker-engine</span><br></pre></td></tr></table></figure>
<h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>有两种方法安装 Docker，这里使用最常用的仓库安装方法。</p>
<h3 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h3><ol>
<li>安装 <code>yum-utils</code></li>
</ol>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> -y yum-utils</span><br></pre></td></tr></table></figure>
<ol>
<li>建立仓库</li>
</ol>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --<span class="built_in">add</span>-repo http<span class="variable">s:</span>//download.docker.<span class="keyword">com</span>/linux/centos/docker-<span class="keyword">ce</span>.repo</span><br></pre></td></tr></table></figure>
<h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><ol>
<li>更新 <code>yum</code> 包索引</li>
</ol>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo yum makecache fast</span></span><br></pre></td></tr></table></figure>
<ol>
<li>安装最新版 Docker（<strong>如需安装指定版本请跳过此步</strong>）</li>
</ol>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> docker-ce</span><br></pre></td></tr></table></figure>
<ol>
<li>安装指定版本 Docker</li>
</ol>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> docker-ce-&lt;<span class="keyword">VERSION</span>&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>建议在生产服务器上总是安装指定版本 Docker。先使用 <code>yum list</code> 命令列出所有版本。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> yum list docker-ce.x86_64  --showduplicates |sort -r</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"></span></span><br></pre></td></tr></table></figure>
</blockquote>
<p>&gt;</p>
<blockquote>
<p>这个命令安版本号排序列出 Docker CE 的二进制包。</p>
</blockquote>
<ol>
<li>启动 Docker</li>
</ol>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure>
<h3 id="升级-Docker"><a href="#升级-Docker" class="headerlink" title="升级 Docker"></a>升级 Docker</h3><p>如果希望升级 Docker，首先运行 <code>sudo yum makecache fast</code>，然后按照以上步骤重新选择新版本安装。</p>
<p><strong>参考资料</strong></p>
<p><a href="https://docs.docker.com/engine/installation/linux/centos/#install-docker" target="_blank" rel="noopener">Get Docker for CentOS</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Docker </tag>
            
            <tag> ContOS </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[使用 mongorestore 恢复 MongoDB 备份]]></title>
      <url>/2017/04/11/%E4%BD%BF%E7%94%A8-mongorestore-%E6%81%A2%E5%A4%8D-MongoDB-%E5%A4%87%E4%BB%BD/</url>
      <content type="html"><![CDATA[<p>上一篇<a href="https://brickyang.github.io/2017/03/02/Linux-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD-MongoDB/">《Linux 自动定时备份 MongoDB》</a>文章中说了如何使用 <code>mongodump</code> 命令备份 MongoDB 数据库。这里说明一下如何使用 <code>mongorestore</code> 命令恢复备份。</p>
<p><code>mongodump</code> 和 <code>mongorestore</code> 是一对命令，分别用于备份和恢复数据。</p>
<p><code>mongorestore</code> 命令默认将 <code>/dump</code> 文件夹（同时也是 <code>mongodump</code> 的默认备份文件夹）下的所有数据恢复到相应的数据库中，也接受很多选项控制备份操作。</p>
<p>我们最常用一个的操作需求是：</p>
<blockquote>
<p>将指定的备份文件恢复到指定数据库的指定文档</p>
</blockquote>
<p>其对应的命令是</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -d <span class="tag">&lt;<span class="name">DATABASE</span>&gt;</span> -c <span class="tag">&lt;<span class="name">COLLECTION</span>&gt;</span> <span class="tag">&lt;<span class="name">PATH</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>PATH</code> 就是要恢复的数据文件夹或文件，用于恢复整个数据库或指定恢复一个列的数据。</p>
<p><strong>参考资料</strong></p>
<p><a href="https://docs.mongodb.com/manual/reference/program/mongorestore/" target="_blank" rel="noopener">mongorestore</a></p>
]]></content>
      
        
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[如何用源生的 React， Webpack，ES6 来使用 Ant Design 组件库？]]></title>
      <url>/2017/03/17/%E5%A6%82%E4%BD%95%E7%94%A8%E6%BA%90%E7%94%9F%E7%9A%84-React%EF%BC%8C-Webpack%EF%BC%8CES6-%E6%9D%A5%E4%BD%BF%E7%94%A8-AantDdesign-%E7%BB%84%E4%BB%B6%E5%BA%93%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>本文是在知乎同名问题下的回答，在这里也记录一下。</p>
<p><strong>Link：</strong> <a href="https://www.zhihu.com/question/45088537/answer/152124079" target="_blank" rel="noopener">知乎原回答</a>，<a href="https://github.com/brickyang/antd-demo" target="_blank" rel="noopener">GitHub demo</a></p>
<p><strong>以下是在知乎的回答</strong></p>
<p>最近刚好开始尝试 Ant Design。之前我用过 Bootstrap、Semantic UI 和 Material Design Lite。和这些库相比 antd 的确是有自己的优势的。</p>
<p>针对题主的问题，我可以分享点自己的经验。</p>
<p>GitHub 的 demo 代码：<a href="https://github.com/brickyang/antd-demo" target="_blank" rel="noopener">antd-demo</a></p>
<p>这个 demo 是我从实际项目中摘出来的。用了 React Router、Webpack 和 Babel。其中 Webpack 用了 <code>assets-webpack-plugin</code> 和 <code>extract-text-webpack-plugin</code> 两个插件。</p>
<p>其实在实际项目中还用了 CSSModule 和 postcss，这里为了简化就去掉了。</p>
<p>另外还用了 <code>webpack-dev-server</code> 和 <code>react-hot-loader</code>，都是开发必不可少的，所以就留着了。</p>
<p><img src="https://pic4.zhimg.com/v2-47b5384132978e73140ada66b71d48db_r.png" alt=""></p>
<p>这是文件结构：</p>
<ul>
<li><code>/build</code>：Webpack 构建的 js 和 css 文件</li>
<li><code>/config</code>：应用的配置文件，包括 webpack.config 和 webpack.config.dev 的</li>
<li><code>/src</code>：源代码</li>
<li><code>/src/components</code>：用于其他页面的 React 组件</li>
<li><code>/src/Dashboard</code>：应用的 Dashboard 页</li>
<li><code>/src/Login</code>：应用的 Login 页</li>
<li><code>/src/router</code>：React Router 实现的路由</li>
<li><code>/src/index.jsx</code>：前端入口页面</li>
<li><code>/src/server.js</code>：一个简单的 Node 服务器</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下载下来之后运行 <code>npm start</code> 。在浏览器中访问 <code>localhost:3000</code> 即可。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"start": "npm run babel-w &amp; npm run dev-webpack &amp; npm run server",</span><br><span class="line">"dev-webpack": "node webpack-dev-server.js",</span><br><span class="line">"server": "NODE_ENV=development nodemon dist/server.js"</span><br></pre></td></tr></table></figure>
<p><code>npm start</code> 做了两件事：</p>
<ol>
<li>启动 <code>webpack-dev-server</code>。Webpack 构建出临时文件，并由 <code>webpack-dev-server</code> 提供（localhost:8080/build）。通过插件实现了动态加载和文件分离。</li>
<li>启动 Node 服务器，提供访问服务。</li>
</ol>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> assetsPlugin = <span class="built_in">require</span>(<span class="string">'assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> extractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./index.jsx'</span>,</span><br><span class="line">  context: path.resolve(__dirname, <span class="string">'../src'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].[hash].js'</span>,</span><br><span class="line">    hashDigestLength: <span class="number">7</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../build'</span>),</span><br><span class="line">    publicPath:  <span class="string">'localhost:3000/build/'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'css'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">	loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">	exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">	test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">	use: extractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: <span class="string">'css-loader'</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: extractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: <span class="string">'css-loader'</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        include: path.resolve(__dirname, <span class="string">'../node_modules/antd/lib/'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> assetsPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'assets.json'</span>,</span><br><span class="line">    path: <span class="string">'build'</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> extractTextPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'[name].[hash].css'</span>,</span><br><span class="line">    ignoreOrder: <span class="literal">true</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">    test: <span class="regexp">/(\.jsx|\.js)$/</span>,</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">  &#125;)],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这是 Webpack 2 的配置文件（和 Webpack 1 有不同）。注意这个是用来构建正式文件的，即 <code>webpack.config.js</code>。开发环境中使用的是 <code>webpack.config.dev.js</code>。二者大同小异，主要是开发环境增加了 <code>react-hot-loader</code>，实现了前端热更新。</p>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>如果你只关注前端的话，那么 Babel 是使用 <code>babel-loader</code> 在 Webpack 构建时起作用的，不需要自己手动转换。如果你同时还关注后端，其实自从 Node 7.6 支持箭头函数之后，主要的 ES2015 语法都源生支持了，除了 <code>import/export</code>，不一定非得用 Babel。</p>
<p>如果发现哪里没摘干净或者写错了，欢迎在 issue 指出。</p>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
            <tag> Ant Design </tag>
            
            <tag> Webpack </tag>
            
            <tag> Babel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 中如何设置 container 的时区]]></title>
      <url>/2017/03/16/Docker%20%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%20container%20%E7%9A%84%E6%97%B6%E5%8C%BA/</url>
      <content type="html"><![CDATA[<p>最近在使用 Docker 时发现 container 中的时区是 UTC。这是因为我的基础镜像是官方的 <code>node:7.6</code> 。Docker Store 上的官方镜像基本上都默认是 UTC 时区，需要我们手动设置一下。</p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>如果你使用 Dockerfile 制作自己的镜像，那么只需要在 Dockerfile 中加入下面两句就可以了：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="bash">RUN dpkg-reconfigure -f noninteractive tzdata</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</code> 和 <code>dpkg-reconfigure -f noninteractive tzdata</code> 是 Ubuntu 修改时区的命令。Docker 默认使用 Ubuntu 系统。如果你的自定义镜像使用的是其他发行版，那么这里的命令也要改变。</p>
</blockquote>
<p>在制作镜像过程中可以看到以下输出：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Current <span class="keyword">default</span> <span class="built_in">time</span> zone: <span class="comment">'Asia/Shanghai'</span></span><br><span class="line">Local <span class="built_in">time</span> <span class="keyword">is</span> <span class="built_in">now</span>:      Thu Mar <span class="number">16</span> <span class="number">12</span>:<span class="number">51</span>:<span class="number">35</span> CST <span class="number">2017.</span></span><br><span class="line">Universal <span class="built_in">Time</span> <span class="keyword">is</span> <span class="built_in">now</span>:  Thu Mar <span class="number">16</span> <span class="number">04</span>:<span class="number">51</span>:<span class="number">35</span> UTC <span class="number">2017.</span></span><br></pre></td></tr></table></figure>
<p>修改成功。以后这个镜像生成的 container 就都是北京时间了。</p>
<h2 id="同步主机时区"><a href="#同步主机时区" class="headerlink" title="同步主机时区"></a>同步主机时区</h2><p>利用 <code>volume</code> 可以在启动一个 container 时指定使用主机的时区文件，就可以把 container 的时区与主机同步：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v <span class="regexp">/etc/</span><span class="string">localtime:</span><span class="regexp">/etc/</span>localtime &lt;<span class="string">IMAGE:</span>TAG&gt;</span><br></pre></td></tr></table></figure>
<p>这种方法的好处是不会修改镜像，适合需要在不同时区主机上运行的场景。</p>
<h2 id="运行中的-container"><a href="#运行中的-container" class="headerlink" title="运行中的 container"></a>运行中的 container</h2><p>如果你不想新建镜像或者重启 container，那么也可以直接进入 container 修改。执行：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;CONTAINER <span class="built_in">NAME</span>&gt; bash</span><br></pre></td></tr></table></figure>
<p>进入 container 之后执行：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; <span class="string">/etc/timezone</span></span><br><span class="line">dpkg-reconfigure -f noninteractive tzdata</span><br></pre></td></tr></table></figure>
<blockquote>
<p>仍然需要注意不同发行版命令的差别。</p>
</blockquote>
<p>这里和 Docker 有关的主要是如何进入 container，进去之后该怎么操作就怎么操作。</p>
]]></content>
      
        
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Linux </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用 Docker 运行 MongoDB]]></title>
      <url>/2017/03/15/%E5%88%A9%E7%94%A8-Docker-%E8%BF%90%E8%A1%8C-MongoDB/</url>
      <content type="html"><![CDATA[<p>在服务器上通过 Docker 运行 MongoDB，可以省略本地安装数据库的步骤，并且日常的运维和使用与本地安装基本没有区别。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>我们将使用官方的 <code>mongo:3.4</code> 镜像（image），并将 <code>27017</code> 端口映射到主机端口，同时利用 Docker Volume 将数据库文件保存在主机上而非容器（container）中。</p>
<p>通过端口映射，可以直接连接主机的 <code>27017</code> 端口。比如如果你在使用一些 GUI 管理工具，不会有任何影响。</p>
<p>通过 Volume 将文件保存在主机，与容器分离，数据的使用与容器无关，所有针对数据的操作（比如备份、恢复）都不受影响。</p>
<h2 id="运行-mongo"><a href="#运行-mongo" class="headerlink" title="运行 mongo"></a>运行 mongo</h2><p>这里我们直接使用官方的 mong 镜像。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="keyword">name</span> &lt;YOUR-<span class="keyword">NAME</span>&gt; -p <span class="number">27017</span>:<span class="number">27017</span> -v /<span class="keyword">data</span>/db:/<span class="keyword">data</span>/db -d mongo:<span class="number">3.4</span> --auth</span><br></pre></td></tr></table></figure>
<p><code>—name</code> 指定库的名字，如果不指定会使用一串随机字符串。</p>
<p><code>-p 27017:27017</code> 官方的镜像已经暴露了 <code>27017</code> 端口，我们将它映射到主机的端口上。如果你不使用默认端口，将 <code>:</code> 前面的数字改成自定义端口。</p>
<p><code>-v /data/db:/data/db</code> 冒号前面的是主机上的文件路径，将它挂载到库中的文件夹下，实际对文件的读写就会在主机文件上操作。</p>
<p><code>-d</code> 在后台运行。</p>
<p><code>mongo:3.4</code> 指定镜像版本，默认是 <code>latest</code> 。建议总是自己指定版本。</p>
<p><code>—auth</code> 以 <code>auth</code> 模式运行 mongo。</p>
<p>然后执行一下 <code>docker ps</code> 确认一下库已经正常运行起来。</p>
<h2 id="新建管理员"><a href="#新建管理员" class="headerlink" title="新建管理员"></a>新建管理员</h2><p>现在我们需要进入 mongo shell 操作：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;YOUR-NAME&gt; mongo admin</span><br><span class="line">&gt; db.createUser(&#123; <span class="string">user:</span> <span class="string">'&lt;USER&gt;'</span>, <span class="string">pwd:</span> <span class="string">'&lt;PASSWORD&gt;'</span>, <span class="string">roles:</span> [ &#123; <span class="string">role:</span> <span class="string">'userAdminAnyDatabase'</span>, <span class="string">db:</span> <span class="string">'admin'</span> &#125; ]&#125;);</span><br><span class="line">Successfully added <span class="string">user:</span> &#123;</span><br><span class="line">    <span class="string">"user"</span> : <span class="string">"&lt;USER&gt;"</span>,</span><br><span class="line">    <span class="string">"roles"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"role"</span> : <span class="string">"userAdminAnyDatabase"</span>,</span><br><span class="line">            <span class="string">"db"</span> : <span class="string">"admin"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以后想以管理员身份登入 mongo shell 就可以运行：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it <span class="tag">&lt;<span class="name">YOUR-NAME</span>&gt;</span> mongo -u <span class="tag">&lt;<span class="name">USER</span>&gt;</span> -p <span class="tag">&lt;<span class="name">PASSWORD</span>&gt;</span> --authenticationDatabase admin</span><br></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>现在我们就可以像本地安装的 mong 一样操作了。如果误删了数据库管理员，可以停掉正在运行的库，然后去掉 <code>—auth</code> 重新运行一个新库，登录进去新建用户即可。</p>
]]></content>
      
        
        <tags>
            
            <tag> Docker </tag>
            
            <tag> MongoDB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 自动定时备份 MongoDB]]></title>
      <url>/2017/03/02/Linux-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD-MongoDB/</url>
      <content type="html"><![CDATA[<p>本文介绍在 Linux 系统下，使用 <code>mongodump</code> 命令自动定时备份数据库的方法。</p>
<h2 id="mongodump"><a href="#mongodump" class="headerlink" title="mongodump"></a>mongodump</h2><p><code>mongodump</code> 是 MongoDB 提供的一个工具，用于备份数据库，配合使用 <code>mongorestore</code> 恢复工具使用。这套工具适合小型应用或开发环境。</p>
<p>运行 <code>mongodump</code> 和 <code>mongorestore</code> 时需要读取正在运行的数据库实例，因此会影响数据库性能。一方面是运行时需要占用系统资源，另一方面，运行这两个命令时数据库会强制通过内存读取所有数据，可能导致读取的不常用数据覆盖常用数据，从而影响数据库日常运行的性能。</p>
<p><em>2.2及以上版本的 <code>mongodump</code> 数据格式与低版本<strong>不兼容</strong>，因此请勿使用高版本工具备份低版本数据。</em></p>
<p><code>mongodump</code> 不会备份 <code>local</code> 数据库。</p>
<p>直接运行 <code>mongodump</code> 命令，默认备份本地运行在27017端口下的 MongoDB 实例中的所有数据库（<code>local</code> 除外），并在当前目录下生成 <code>dump/</code> 路径存放备份文件。</p>
<p>你也可以使用以下命令指定备份的数据库位置、端口、输出文件位置、备份数据库和文档：</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodump <span class="params">--host</span> mongodb.example.net <span class="params">--port</span> 27017 <span class="params">--out</span> <span class="string">/data/backup/</span> <span class="params">--db</span> test <span class="params">--collection</span> myCollection</span><br></pre></td></tr></table></figure>
<h2 id="命令脚本"><a href="#命令脚本" class="headerlink" title="命令脚本"></a>命令脚本</h2><p>首先我们要创建一个执行备份工作的脚本。在 <code>~/crontab/</code> 下新建一个 <code>.sh</code> 文件：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> ~/crontab</span><br><span class="line"><span class="keyword">vi</span> ~/crontab/mongod_bak.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure>
<p>写入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">DUMP=mongodump</span><br><span class="line">OUT_DIR=/data/backup/mongod/tmp   // 备份文件临时目录</span><br><span class="line">TAR_DIR=/data/backup/mongod       // 备份文件正式目录</span><br><span class="line">DATE=`date +%Y_%m_%d_%H_%M_%S`    // 备份文件将以备份时间保存</span><br><span class="line">DB_USER=&lt;USER&gt;                    // 数据库操作员</span><br><span class="line">DB_PASS=&lt;PASSWORD&gt;                // 数据库操作员密码</span><br><span class="line">DAYS=14                           // 保留最新14天的备份</span><br><span class="line">TAR_BAK=<span class="string">"mongod_bak_<span class="variable">$DATE</span>.tar.gz"</span> // 备份文件命名格式</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$OUT_DIR</span>                       // 创建文件夹</span><br><span class="line">rm -rf <span class="variable">$OUT_DIR</span>/*                 // 清空临时目录</span><br><span class="line">mkdir -p <span class="variable">$OUT_DIR</span>/<span class="variable">$DATE</span>           // 创建本次备份文件夹</span><br><span class="line"><span class="variable">$DUMP</span> -u <span class="variable">$DB_USER</span> -p <span class="variable">$DB_PASS</span> -o <span class="variable">$OUT_DIR</span>/<span class="variable">$DATE</span>  // 执行备份命令</span><br><span class="line">tar -zcvf <span class="variable">$TAR_DIR</span>/<span class="variable">$TAR_BAK</span> <span class="variable">$OUT_DIR</span>/<span class="variable">$DATE</span>       // 将备份文件打包放入正式目录</span><br><span class="line">find <span class="variable">$TAR_DIR</span>/ -mtime +<span class="variable">$DAYS</span> -delete             // 删除14天前的旧备份</span><br></pre></td></tr></table></figure>
<p>这个脚本完成了备份、打包、删除一定时间之前旧备份的工作。注意其中的 <code>user</code> 需要具有对希望备份的数据库具有 <code>find</code> 操作权限。</p>
<p>保存好脚本后别忘了将它设为可执行：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ~<span class="regexp">/crontab/m</span>ongod_bak.sh</span><br></pre></td></tr></table></figure>
<p>现在你可以试着执行一下 <code>./mongod_bak.sh</code>，就会在备份文件夹中看到打包好的备份数据了。</p>
<h2 id="自动运行"><a href="#自动运行" class="headerlink" title="自动运行"></a>自动运行</h2><p>备份脚本写好之后，就需要让它自动运行。直接使用 Linux 的 <code>crontab</code> 命令即可：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>crontab</span><br></pre></td></tr></table></figure>
<p>在底部添加：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">2</span> * * * root ~/crontab/mongod_bak.sh</span><br></pre></td></tr></table></figure>
<p>这一行表示在每天凌晨02:00以 root 身份运行备份数据库的脚本。然后重启 crond 使其生效：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/systemctl restart  crond.service</span><br><span class="line">chkconfig crond on    <span class="comment">// 设为开机启动</span></span><br></pre></td></tr></table></figure>
<p>至此，一个自动运行的备份脚本就设置好了。以后每天凌晨02:00都会有一份新鲜的备份文件放在指定目录中，并且会自动删除14天前的旧备份。</p>
<h2 id="恢复备份"><a href="#恢复备份" class="headerlink" title="恢复备份"></a>恢复备份</h2><p><a href="https://brickyang.github.io/2017/04/11/%E4%BD%BF%E7%94%A8-mongorestore-%E6%81%A2%E5%A4%8D-MongoDB-%E5%A4%87%E4%BB%BD/">使用 mongorestore 恢复 MongoDB 备份</a></p>
<p><strong>参考资料</strong></p>
<p><a href="https://docs.mongodb.com/manual/tutorial/backup-and-restore-tools/" target="_blank" rel="noopener">Back Up and Restore with MongoDB Tools</a></p>
<p><a href="https://zh.wikipedia.org/zh-hans/Cron" target="_blank" rel="noopener">Cron - Wikipedia</a></p>
]]></content>
      
        
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOS 7 安装 shadowsocks 客户端]]></title>
      <url>/2017/01/14/CentOS-7-%E5%AE%89%E8%A3%85-Shadowsocks-%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近由于在阿里云从 GitHub 拖代码非常困难，因此萌生了在服务器上使用 shadowsocks 的念头。</p>
<p>本文记录了我在 CentOS 7 上成功安装运行 shadowsocks 客户端的过程。</p>
<p><strong>本文的过程我已在本地 CentOS 上成功运行，尚未在阿里云实测。</strong></p>
<p><strong>给新手：</strong>这里介绍的是安装 shadowsocks <strong>客户端</strong>的过程，也就是让服务器能正常访问 GitHub 的方法。你需要已经有一个 shadowsocks 服务端。</p>
<p>一般网上找到的「CentOS 安装 shadowsocks」文章多数都是讲安装服务端的。</p>
<h2 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h2><p>Pip 是 Python 的包管理工具，这里我们用 pip 安装 shadowsocks。</p>
<p>有些文章会介绍用 <code>yum install -y pip</code> 安装，我用的是官方一个最小化的 CentOS，没有这个包，所以手动安装。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">"https://bootstrap.pypa.io/get-pip.py"</span> -<span class="keyword">o</span> <span class="string">"get-pip.py"</span></span><br><span class="line"><span class="keyword">python</span> <span class="built_in">get</span>-pip.<span class="keyword">py</span></span><br></pre></td></tr></table></figure>
<h2 id="Shadowsocks-客户端"><a href="#Shadowsocks-客户端" class="headerlink" title="Shadowsocks 客户端"></a>Shadowsocks 客户端</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> <span class="comment">--upgrade pip</span></span><br><span class="line">pip <span class="keyword">install</span> shadowsocks</span><br></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>新建配置文件：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>shadowsocks.json</span><br></pre></td></tr></table></figure>
<p>填写以下内容</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"server"</span>:<span class="string">"x.x.x.x"</span>,             #你的 ss 服务器 ip</span><br><span class="line">  <span class="string">"server_port"</span>:0,                #你的 ss 服务器端口</span><br><span class="line">  <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,   #本地ip</span><br><span class="line">  <span class="string">"local_port"</span>:0,                 #本地端口</span><br><span class="line">  <span class="string">"password"</span>:<span class="string">"password"</span>,          #连接 ss 密码</span><br><span class="line">  <span class="string">"timeout"</span>:300,                  #等待超时</span><br><span class="line">  <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,         #加密方式</span><br><span class="line">  <span class="string">"workers"</span>: 1                    #工作线程数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup sslocal -c <span class="meta-keyword">/etc/</span>shadowsocks.json <span class="meta-keyword">/dev/</span>null <span class="number">2</span>&gt;<span class="variable">&amp;1</span> &amp;</span><br><span class="line">echo <span class="string">" nohup sslocal -c /etc/shadowsocks.json /dev/null 2&gt;&amp;1 &amp;"</span> <span class="meta-keyword">/etc/</span>rc.local   <span class="meta">#设置自启动</span></span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>运行 <code>curl --socks5 127.0.0.1:1985 http://httpbin.org/ip</code>，如果返回你的 ss 服务器 ip 则测试成功：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"origin"</span>: <span class="string">"x.x.x.x"</span>       #你的 ss 服务器 ip</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Privoxy"><a href="#Privoxy" class="headerlink" title="Privoxy"></a>Privoxy</h2><p>Shadowsocks 是一个 socket5 服务，我们需要使用 Privoxy 把流量转到 http／https 上。</p>
<p>###下载安装文件</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//www.privoxy.org/sf-download-mirror/Sources/3.0.26%20%28stable%29/privoxy-3.0.26-stable-src.tar.gz</span></span><br><span class="line">tar -zxvf privoxy-<span class="number">3.0</span>.<span class="number">26</span>-stable-src<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">cd privoxy-<span class="number">3.0</span>.<span class="number">26</span>-stable</span><br></pre></td></tr></table></figure>
<p>privoxy-3.0.26-stable 是目前最新的稳定版，建议在下载前去 <a href="https://www.privoxy.org/sf-download-mirror/Sources/" target="_blank" rel="noopener">Privoxy 官网下载页</a> 检查一下版本。</p>
<h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><p>Privoxy 强烈不建议使用 root 用户运行，所以我们使用 <code>useradd privoxy</code> 新建一个用户.</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">autoheader <span class="meta">&amp;&amp; autoconf</span></span><br><span class="line">./configure</span><br><span class="line">make <span class="meta">&amp;&amp; make install</span></span><br></pre></td></tr></table></figure>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>privoxy<span class="regexp">/config</span></span><br></pre></td></tr></table></figure>
<p>找到以下两句，确保没有注释掉</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen-address <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">8118</span>   # <span class="number">8118</span> 是默认端口，不用改，下面会用到</span><br><span class="line">forward-socks5t / <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">0</span> . # 这里的端口写 shadowsocks 的本地端口（注意最后那个 . 不要漏了）</span><br></pre></td></tr></table></figure>
<h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privoxy --<span class="keyword">user</span> <span class="title">privoxy</span> /usr/local/etc/privoxy/config</span><br></pre></td></tr></table></figure>
<h2 id="配置-etc-profile"><a href="#配置-etc-profile" class="headerlink" title="配置 /etc/profile"></a>配置 /etc/profile</h2><p>编辑：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vi</span> /etc/<span class="keyword">profile</span></span><br></pre></td></tr></table></figure>
<p>添加下面两句：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">http_proxy</span>=http://127.0.0.1:8118       #这里的端口和上面 privoxy 中的保持一致</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">https_proxy</span>=http://127.0.0.1:8118</span><br></pre></td></tr></table></figure>
<p>运行以下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure>
<p>测试生效：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl www<span class="selector-class">.google</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure>
<p>返回一大堆 HTML 则说明 shadowsocks 正常工作了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果不能访问，请重启机器，依次打开 shadowsocks 和 privoxy 再测试.</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup sslocal -c <span class="meta-keyword">/etc/</span>shadowsocks.json <span class="meta-keyword">/dev/</span>null <span class="number">2</span>&gt;<span class="variable">&amp;1</span> &amp;</span><br><span class="line">privoxy --user privoxy <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/etc/</span>privoxy/config</span><br></pre></td></tr></table></figure>
<p>如果不需要用代理了，记得把 <code>/etc/profile</code> 里的配置注释掉，不然会一直走代理流量。</p>
<hr>
<ul>
<li><a href="https://www.privoxy.org/" target="_blank" rel="noopener">Privoxy - Home Page</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Shadowsocks" target="_blank" rel="noopener">Shadowsocks - Wikis</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Shadowsocks </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
