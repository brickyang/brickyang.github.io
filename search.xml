<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[如何用源生的 React， Webpack，ES6 来使用 Ant Design 组件库？]]></title>
      <url>http://brickyang.github.io/2017/03/17/%E5%A6%82%E4%BD%95%E7%94%A8%E6%BA%90%E7%94%9F%E7%9A%84-React%EF%BC%8C-Webpack%EF%BC%8CES6-%E6%9D%A5%E4%BD%BF%E7%94%A8-AantDdesign-%E7%BB%84%E4%BB%B6%E5%BA%93%EF%BC%9F/</url>
      <content type="html"><![CDATA[<p>本文是在知乎同名问题下的回答，在这里也记录一下。</p>
<p><strong>Link：</strong> <a href="https://www.zhihu.com/question/45088537/answer/152124079" target="_blank" rel="external">知乎原回答</a>，<a href="https://github.com/brickyang/antd-demo" target="_blank" rel="external">GitHub demo</a></p>
<p><strong>以下是在知乎的回答</strong></p>
<p>最近刚好开始尝试 Ant Design。之前我用过 Bootstrap、Semantic UI 和 Material Design Lite。和这些库相比 antd 的确是有自己的优势的。</p>
<p>针对题主的问题，我可以分享点自己的经验。</p>
<p>GitHub 的 demo 代码：<a href="https://github.com/brickyang/antd-demo" target="_blank" rel="external">antd-demo</a></p>
<p>这个 demo 是我从实际项目中摘出来的。用了 React Router、Webpack 和 Babel。其中 Webpack 用了 <code>assets-webpack-plugin</code> 和 <code>extract-text-webpack-plugin</code> 两个插件。</p>
<p>其实在实际项目中还用了 CSSModule 和 postcss，这里为了简化就去掉了。</p>
<p>另外还用了 <code>webpack-dev-server</code> 和 <code>react-hot-loader</code>，都是开发必不可少的，所以就留着了。</p>
<p><img src="https://pic4.zhimg.com/v2-47b5384132978e73140ada66b71d48db_r.png" alt=""></p>
<p>这是文件结构：</p>
<ul>
<li><code>/build</code>：Webpack 构建的 js 和 css 文件</li>
<li><code>/config</code>：应用的配置文件，包括 webpack.config 和 webpack.config.dev 的</li>
<li><code>/src</code>：源代码</li>
<li><code>/src/components</code>：用于其他页面的 React 组件</li>
<li><code>/src/Dashboard</code>：应用的 Dashboard 页</li>
<li><code>/src/Login</code>：应用的 Login 页</li>
<li><code>/src/router</code>：React Router 实现的路由</li>
<li><code>/src/index.jsx</code>：前端入口页面</li>
<li><code>/src/server.js</code>：一个简单的 Node 服务器</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下载下来之后运行 <code>npm start</code> 。在浏览器中访问 <code>localhost:3000</code> 即可。</p>
<h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">"start": "npm run babel-w &amp; npm run dev-webpack &amp; npm run server",</div><div class="line">"dev-webpack": "node webpack-dev-server.js",</div><div class="line">"server": "NODE_ENV=development nodemon dist/server.js"</div></pre></td></tr></table></figure>
<p><code>npm start</code> 做了两件事：</p>
<ol>
<li>启动 <code>webpack-dev-server</code>。Webpack 构建出临时文件，并由 <code>webpack-dev-server</code> 提供（localhost:8080/build）。通过插件实现了动态加载和文件分离。</li>
<li>启动 Node 服务器，提供访问服务。</li>
</ol>
<h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</div><div class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</div><div class="line"><span class="keyword">const</span> assetsPlugin = <span class="built_in">require</span>(<span class="string">'assets-webpack-plugin'</span>);</div><div class="line"><span class="keyword">const</span> extractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</div><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = &#123;</div><div class="line">  <span class="attr">entry</span>: <span class="string">'./index.jsx'</span>,</div><div class="line">  <span class="attr">context</span>: path.resolve(__dirname, <span class="string">'../src'</span>),</div><div class="line">  <span class="attr">output</span>: &#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].[hash].js'</span>,</div><div class="line">    <span class="attr">hashDigestLength</span>: <span class="number">7</span>,</div><div class="line">    <span class="attr">path</span>: path.resolve(__dirname, <span class="string">'../build'</span>),</div><div class="line">    <span class="attr">publicPath</span>:  <span class="string">'localhost:3000/build/'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">resolve</span>: &#123;</div><div class="line">    <span class="attr">extensions</span>: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'css'</span>]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">module</span>: &#123;</div><div class="line">    <span class="attr">rules</span>: [</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.jsx?$/</span>,</div><div class="line">	<span class="attr">loader</span>: <span class="string">'babel-loader'</span>,</div><div class="line">	<span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">	<span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</div><div class="line">	<span class="attr">use</span>: extractTextPlugin.extract(&#123;</div><div class="line">          <span class="attr">fallback</span>: <span class="string">'style-loader'</span>,</div><div class="line">          <span class="attr">use</span>: <span class="string">'css-loader'</span>,</div><div class="line">        &#125;),</div><div class="line">        <span class="attr">exclude</span>: <span class="regexp">/node_modules/</span></div><div class="line">      &#125;,</div><div class="line">      &#123;</div><div class="line">        <span class="attr">test</span>: <span class="regexp">/\.css$/</span>,</div><div class="line">        <span class="attr">use</span>: extractTextPlugin.extract(&#123;</div><div class="line">          <span class="attr">fallback</span>: <span class="string">'style-loader'</span>,</div><div class="line">          <span class="attr">use</span>: <span class="string">'css-loader'</span>,</div><div class="line">        &#125;),</div><div class="line">        <span class="attr">include</span>: path.resolve(__dirname, <span class="string">'../node_modules/antd/lib/'</span>)</div><div class="line">      &#125;</div><div class="line">    ]</div><div class="line">  &#125;,</div><div class="line">  <span class="attr">plugins</span>: [</div><div class="line">    <span class="keyword">new</span> assetsPlugin(&#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'assets.json'</span>,</div><div class="line">    <span class="attr">path</span>: <span class="string">'build'</span></div><div class="line">  &#125;),</div><div class="line">  <span class="keyword">new</span> extractTextPlugin(&#123;</div><div class="line">    <span class="attr">filename</span>: <span class="string">'[name].[hash].css'</span>,</div><div class="line">    <span class="attr">ignoreOrder</span>: <span class="literal">true</span></div><div class="line">  &#125;),</div><div class="line">  <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</div><div class="line">    <span class="attr">test</span>: <span class="regexp">/(\.jsx|\.js)$/</span>,</div><div class="line">    <span class="attr">minimize</span>: <span class="literal">true</span>,</div><div class="line">  &#125;)],</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这是 Webpack 2 的配置文件（和 Webpack 1 有不同）。注意这个是用来构建正式文件的，即 <code>webpack.config.js</code>。开发环境中使用的是 <code>webpack.config.dev.js</code>。二者大同小异，主要是开发环境增加了 <code>react-hot-loader</code>，实现了前端热更新。</p>
<h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>如果你只关注前端的话，那么 Babel 是使用 <code>babel-loader</code> 在 Webpack 构建时起作用的，不需要自己手动转换。如果你同时还关注后端，其实自从 Node 7.6 支持箭头函数之后，主要的 ES2015 语法都源生支持了，除了 <code>import/export</code>，不一定非得用 Babel。</p>
<p>如果发现哪里没摘干净或者写错了，欢迎在 issue 指出。</p>
]]></content>
      
        
        <tags>
            
            <tag> React </tag>
            
            <tag> Ant Design </tag>
            
            <tag> Webpack </tag>
            
            <tag> Babel </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Docker 中如何设置 container 的时区]]></title>
      <url>http://brickyang.github.io/2017/03/16/Docker%20%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%20container%20%E7%9A%84%E6%97%B6%E5%8C%BA/</url>
      <content type="html"><![CDATA[<p>最近在使用 Docker 时发现 container 中的时区是 UTC。这是因为我的基础镜像是官方的 <code>node:7.6</code> 。Docker Store 上的官方镜像基本上都默认是 UTC 时区，需要我们手动设置一下。</p>
<h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>如果你使用 Dockerfile 制作自己的镜像，那么只需要在 Dockerfile 中加入下面两句就可以了：</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone</span></div><div class="line"><span class="keyword">RUN</span><span class="bash"> dpkg-reconfigure <span class="_">-f</span> noninteractive tzdata</span></div></pre></td></tr></table></figure>
<blockquote>
<p><code>echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</code> 和 <code>dpkg-reconfigure -f noninteractive tzdata</code> 是 Ubuntu 修改时区的命令。Docker 默认使用 Ubuntu 系统。如果你的自定义镜像使用的是其他发行版，那么这里的命令也要改变。</p>
</blockquote>
<p>在制作镜像过程中可以看到以下输出：</p>
<figure class="highlight vbscript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Current <span class="keyword">default</span> <span class="built_in">time</span> zone: <span class="comment">'Asia/Shanghai'</span></div><div class="line">Local <span class="built_in">time</span> <span class="keyword">is</span> <span class="built_in">now</span>:      Thu Mar <span class="number">16</span> <span class="number">12</span>:<span class="number">51</span>:<span class="number">35</span> CST <span class="number">2017.</span></div><div class="line">Universal <span class="built_in">Time</span> <span class="keyword">is</span> <span class="built_in">now</span>:  Thu Mar <span class="number">16</span> <span class="number">04</span>:<span class="number">51</span>:<span class="number">35</span> UTC <span class="number">2017.</span></div></pre></td></tr></table></figure>
<p>修改成功。以后这个镜像生成的 container 就都是北京时间了。</p>
<h2 id="同步主机时区"><a href="#同步主机时区" class="headerlink" title="同步主机时区"></a>同步主机时区</h2><p>利用 <code>volume</code> 可以在启动一个 container 时指定使用主机的时区文件，就可以把 container 的时区与主机同步：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run -v <span class="regexp">/etc/</span><span class="string">localtime:</span><span class="regexp">/etc/</span>localtime &lt;<span class="string">IMAGE:</span>TAG&gt;</div></pre></td></tr></table></figure>
<p>这种方法的好处是不会修改镜像，适合需要在不同时区主机上运行的场景。</p>
<h2 id="运行中的-container"><a href="#运行中的-container" class="headerlink" title="运行中的 container"></a>运行中的 container</h2><p>如果你不想新建镜像或者重启 container，那么也可以直接进入 container 修改。执行：</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker <span class="built_in">exec</span> -it &lt;CONTAINER <span class="built_in">NAME</span>&gt; bash</div></pre></td></tr></table></figure>
<p>进入 container 之后执行：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone</div><div class="line">dpkg-reconfigure <span class="_">-f</span> noninteractive tzdata</div></pre></td></tr></table></figure>
<blockquote>
<p>仍然需要注意不同发行版命令的差别。</p>
</blockquote>
<p>这里和 Docker 有关的主要是如何进入 container，进去之后该怎么操作就怎么操作。</p>
]]></content>
      
        
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用 Docker 运行 MongoDB]]></title>
      <url>http://brickyang.github.io/2017/03/15/%E5%88%A9%E7%94%A8-Docker-%E8%BF%90%E8%A1%8C-MongoDB/</url>
      <content type="html"><![CDATA[<p>在服务器上通过 Docker 运行 MongoDB，可以省略本地安装数据库的步骤，并且日常的运维和使用与本地安装基本没有区别。</p>
<h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>我们将使用官方的 <code>mongo:3.4</code> 镜像（image），并将 <code>27017</code> 端口映射到主机端口，同时利用 Docker Volume 将数据库文件保存在主机上而非容器（container）中。</p>
<p>通过端口映射，可以直接连接主机的 <code>27017</code> 端口。比如如果你在使用一些 GUI 管理工具，不会有任何影响。</p>
<p>通过 Volume 将文件保存在主机，与容器分离，数据的使用与容器无关，所有针对数据的操作（比如备份、恢复）都不受影响。</p>
<h2 id="运行-mongo"><a href="#运行-mongo" class="headerlink" title="运行 mongo"></a>运行 mongo</h2><p>这里我们直接使用官方的 mong 镜像。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker run --<span class="keyword">name</span> &lt;YOUR-<span class="keyword">NAME</span>&gt; -p <span class="number">27017</span>:<span class="number">27017</span> -v /<span class="keyword">data</span>/db:/<span class="keyword">data</span>/db -d mongo:<span class="number">3.4</span> --auth</div></pre></td></tr></table></figure>
<p><code>—name</code> 指定库的名字，如果不指定会使用一串随机字符串。</p>
<p><code>-p 27017:27017</code> 官方的镜像已经暴露了 <code>27017</code> 端口，我们将它映射到主机的端口上。如果你不使用默认端口，将 <code>:</code> 前面的数字改成自定义端口。</p>
<p><code>-v /data/db:/data/db</code> 冒号前面的是主机上的文件路径，将它挂载到库中的文件夹下，实际对文件的读写就会在主机文件上操作。</p>
<p><code>-d</code> 在后台运行。</p>
<p><code>mongo:3.4</code> 指定镜像版本，默认是 <code>latest</code> 。建议总是自己指定版本。</p>
<p><code>—auth</code> 以 <code>auth</code> 模式运行 mongo。</p>
<p>然后执行一下 <code>docker ps</code> 确认一下库已经正常运行起来。</p>
<h2 id="新建管理员"><a href="#新建管理员" class="headerlink" title="新建管理员"></a>新建管理员</h2><p>现在我们需要进入 mongo shell 操作：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">docker exec -it &lt;YOUR-NAME&gt; mongo admin</div><div class="line">&gt; db.createUser(&#123; <span class="string">user:</span> <span class="string">'&lt;USER&gt;'</span>, <span class="string">pwd:</span> <span class="string">'&lt;PASSWORD&gt;'</span>, <span class="string">roles:</span> [ &#123; <span class="string">role:</span> <span class="string">'userAdminAnyDatabase'</span>, <span class="string">db:</span> <span class="string">'admin'</span> &#125; ]&#125;);</div><div class="line">Successfully added <span class="string">user:</span> &#123;</div><div class="line">    <span class="string">"user"</span> : <span class="string">"&lt;USER&gt;"</span>,</div><div class="line">    <span class="string">"roles"</span> : [</div><div class="line">        &#123;</div><div class="line">            <span class="string">"role"</span> : <span class="string">"userAdminAnyDatabase"</span>,</div><div class="line">            <span class="string">"db"</span> : <span class="string">"admin"</span></div><div class="line">        &#125;</div><div class="line">    ]</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>以后想以管理员身份登入 mongo shell 就可以运行：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">docker exect -it <span class="tag">&lt;<span class="name">YOUR-NAME</span>&gt;</span> mongo -u <span class="tag">&lt;<span class="name">USER</span>&gt;</span> -p <span class="tag">&lt;<span class="name">PASSWORD</span>&gt;</span> --authenticationDatabase admin</div></pre></td></tr></table></figure>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>现在我们就可以像本地安装的 mong 一样操作了。如果误删了数据库管理员，可以停掉正在运行的库，然后去掉 <code>—auth</code> 重新运行一个新库，登录进去新建用户即可。</p>
]]></content>
      
        
        <tags>
            
            <tag> MongoDB </tag>
            
            <tag> Docker </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Linux 自动定时备份 MongoDB]]></title>
      <url>http://brickyang.github.io/2017/03/02/Linux-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD-MongoDB/</url>
      <content type="html"><![CDATA[<p>本文介绍在 Linux 系统下，使用 <code>mongodump</code> 命令自动定时备份数据库的方法。</p>
<h2 id="mongodump"><a href="#mongodump" class="headerlink" title="mongodump"></a>mongodump</h2><p><code>mongodump</code> 是 MongoDB 提供的一个工具，用于备份数据库，配合使用 <code>mongorestore</code> 恢复工具使用。这套工具适合小型应用或开发环境。</p>
<p>运行 <code>mongodump</code> 和 <code>mongorestore</code> 时需要读取正在运行的数据库实例，因此会影响数据库性能。一方面是运行时需要占用系统资源，另一方面，运行这两个命令时数据库会强制通过内存读取所有数据，可能导致读取的不常用数据覆盖常用数据，从而影响数据库日常运行的性能。</p>
<p><em>2.2及以上版本的 <code>mongodump</code> 数据格式与低版本<strong>不兼容</strong>，因此请勿使用高版本工具备份低版本数据。</em></p>
<p><code>mongodump</code> 不会备份 <code>local</code> 数据库。</p>
<p>直接运行 <code>mongodump</code> 命令，默认备份本地运行在27017端口下的 MongoDB 实例中的所有数据库（<code>local</code> 除外），并在当前目录下生成 <code>dump/</code> 路径存放备份文件。</p>
<p>你也可以使用以下命令指定备份的数据库位置、端口、输出文件位置、备份数据库和文档：</p>
<figure class="highlight brainfuck"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="comment">mongodump</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">host</span> <span class="comment">mongodb</span><span class="string">.</span><span class="comment">example</span><span class="string">.</span><span class="comment">net</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">port</span> <span class="comment">27017</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">out</span> <span class="comment">/data/backup/</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">db</span> <span class="comment">test</span> <span class="literal">-</span><span class="literal">-</span><span class="comment">collection</span> <span class="comment">myCollection</span></div></pre></td></tr></table></figure>
<h2 id="命令脚本"><a href="#命令脚本" class="headerlink" title="命令脚本"></a>命令脚本</h2><p>首先我们要创建一个执行备份工作的脚本。在 <code>~/crontab/</code> 下新建一个 <code>.sh</code> 文件：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> ~/crontab</div><div class="line"><span class="keyword">vi</span> ~/crontab/mongod_bak.<span class="keyword">sh</span></div></pre></td></tr></table></figure>
<p>写入以下内容：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="meta">#!/bin/sh</span></div><div class="line">DUMP=mongodump</div><div class="line">OUT_DIR=/data/backup/mongod/tmp   // 备份文件临时目录</div><div class="line">TAR_DIR=/data/backup/mongod       // 备份文件正式目录</div><div class="line">DATE=`date +%Y_%m_%d_%H_%M_%S`    // 备份文件将以备份时间保存</div><div class="line">DB_USER=&lt;USER&gt;                    // 数据库操作员</div><div class="line">DB_PASS=&lt;PASSWORD&gt;                // 数据库操作员密码</div><div class="line">DAYS=14                           // 保留最新14天的备份</div><div class="line">TAR_BAK=<span class="string">"mongod_bak_<span class="variable">$DATE</span>.tar.gz"</span> // 备份文件命名格式</div><div class="line"><span class="built_in">cd</span> <span class="variable">$OUT_DIR</span>                       // 创建文件夹</div><div class="line">rm -rf <span class="variable">$OUT_DIR</span>/*                 // 清空临时目录</div><div class="line">mkdir -p <span class="variable">$OUT_DIR</span>/<span class="variable">$DATE</span>           // 创建本次备份文件夹</div><div class="line"><span class="variable">$DUMP</span> -u <span class="variable">$DB_USER</span> -p <span class="variable">$DB_PASS</span> -o <span class="variable">$OUT_DIR</span>/<span class="variable">$DATE</span>  // 执行备份命令</div><div class="line">tar -zcvf <span class="variable">$TAR_DIR</span>/<span class="variable">$TAR_BAK</span> <span class="variable">$OUT_DIR</span>/<span class="variable">$DATE</span>       // 将备份文件打包放入正式目录</div><div class="line">find <span class="variable">$TAR_DIR</span>/ -mtime +<span class="variable">$DAYS</span> -delete             // 删除14天前的旧备份</div></pre></td></tr></table></figure>
<p>这个脚本完成了备份、打包、删除一定时间之前旧备份的工作。注意其中的 <code>user</code> 需要具有对希望备份的数据库具有 <code>find</code> 操作权限。</p>
<p>保存好脚本后别忘了将它设为可执行：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">chmod +x ~<span class="regexp">/crontab/m</span>ongod_bak.sh</div></pre></td></tr></table></figure>
<p>现在你可以试着执行一下 <code>./mongod_bak.sh</code>，就会在备份文件夹中看到打包好的备份数据了。</p>
<h2 id="自动运行"><a href="#自动运行" class="headerlink" title="自动运行"></a>自动运行</h2><p>备份脚本写好之后，就需要让它自动运行。直接使用 Linux 的 <code>crontab</code> 命令即可：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi <span class="regexp">/etc/</span>crontab</div></pre></td></tr></table></figure>
<p>在底部添加：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="symbol">0 </span><span class="number">2</span> * * * root ~/crontab/mongod_bak.sh</div></pre></td></tr></table></figure>
<p>这一行表示在每天凌晨02:00以 root 身份运行备份数据库的脚本。然后重启 crond 使其生效：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">/bin/systemctl restart  crond<span class="selector-class">.service</span></div><div class="line">chkconfig crond on    <span class="comment">// 设为开机启动</span></div></pre></td></tr></table></figure>
<p>至此，一个自动运行的备份脚本就设置好了。以后每天凌晨02:00都会有一份新鲜的备份文件放在指定目录中，并且会自动删除14天前的旧备份。</p>
<p><strong>参考资料</strong></p>
<p><a href="https://docs.mongodb.com/manual/tutorial/backup-and-restore-tools/" target="_blank" rel="external">Back Up and Restore with MongoDB Tools</a></p>
<p><a href="https://zh.wikipedia.org/zh-hans/Cron" target="_blank" rel="external">Cron - Wikipedia</a></p>
]]></content>
      
        
        <tags>
            
            <tag> MongoDB </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CentOS 7 安装 shadowsocks 客户端]]></title>
      <url>http://brickyang.github.io/2017/01/14/CentOS-7-%E5%AE%89%E8%A3%85-Shadowsocks-%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近由于在阿里云从 GitHub 拖代码非常困难，因此萌生了在服务器上使用 shadowsocks 的念头。</p>
<p>本文记录了我在 CentOS 7 上成功安装运行 shadowsocks 客户端的过程。</p>
<p><strong>本文的过程我已在本地 CentOS 上成功运行，尚未在阿里云实测。</strong></p>
<p><strong>给新手：</strong>这里介绍的是安装 shadowsocks <strong>客户端</strong>的过程，也就是让服务器能正常访问 GitHub 的方法。你需要已经有一个 shadowsocks 服务端。</p>
<p>一般网上找到的「CentOS 安装 shadowsocks」文章多数都是讲安装服务端的。</p>
<h2 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h2><p>Pip 是 Python 的包管理工具，这里我们用 pip 安装 shadowsocks。</p>
<p>有些文章会介绍用 <code>yum install -y pip</code> 安装，我用的是官方一个最小化的 CentOS，没有这个包，所以手动安装。</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">curl <span class="string">"https://bootstrap.pypa.io/get-pip.py"</span> -<span class="keyword">o</span> <span class="string">"get-pip.py"</span></div><div class="line"><span class="keyword">python</span> <span class="built_in">get</span>-pip.<span class="keyword">py</span></div></pre></td></tr></table></figure>
<h2 id="Shadowsocks-客户端"><a href="#Shadowsocks-客户端" class="headerlink" title="Shadowsocks 客户端"></a>Shadowsocks 客户端</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">pip <span class="keyword">install</span> <span class="comment">--upgrade pip</span></div><div class="line">pip <span class="keyword">install</span> shadowsocks</div></pre></td></tr></table></figure>
<h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>新建配置文件：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi <span class="regexp">/etc/</span>shadowsocks.json</div></pre></td></tr></table></figure>
<p>填写以下内容</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"server"</span>:<span class="string">"x.x.x.x"</span>,             <span class="meta">#你的 ss 服务器 ip</span></div><div class="line">  <span class="string">"server_port"</span>:<span class="number">0</span>,                <span class="meta">#你的 ss 服务器端口</span></div><div class="line">  <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,   <span class="meta">#本地ip</span></div><div class="line">  <span class="string">"local_port"</span>:<span class="number">0</span>,                 <span class="meta">#本地端口</span></div><div class="line">  <span class="string">"password"</span>:<span class="string">"password"</span>,          <span class="meta">#连接 ss 密码</span></div><div class="line">  <span class="string">"timeout"</span>:<span class="number">300</span>,                  <span class="meta">#等待超时</span></div><div class="line">  <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,         <span class="meta">#加密方式</span></div><div class="line">  <span class="string">"workers"</span>: <span class="number">1</span>                    <span class="meta">#工作线程数</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nohup sslocal -c <span class="meta-keyword">/etc/</span>shadowsocks.json <span class="meta-keyword">/dev/</span>null <span class="number">2</span>&gt;<span class="variable">&amp;1</span> &amp;</div><div class="line">echo <span class="string">" nohup sslocal -c /etc/shadowsocks.json /dev/null 2&gt;&amp;1 &amp;"</span> <span class="meta-keyword">/etc/</span>rc.local   <span class="meta">#设置自启动</span></div></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>运行 <code>curl --socks5 127.0.0.1:1985 http://httpbin.org/ip</code>，如果返回你的 ss 服务器 ip 则测试成功：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"origin"</span>: <span class="string">"x.x.x.x"</span>       #你的 ss 服务器 ip</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="Privoxy"><a href="#Privoxy" class="headerlink" title="Privoxy"></a>Privoxy</h2><p>Shadowsocks 是一个 socket5 服务，我们需要使用 Privoxy 把流量转到 http／https 上。</p>
<p>###下载安装文件</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">wget http:<span class="comment">//www.privoxy.org/sf-download-mirror/Sources/3.0.26%20%28stable%29/privoxy-3.0.26-stable-src.tar.gz</span></div><div class="line">tar -zxvf privoxy-<span class="number">3.0</span>.<span class="number">26</span>-stable-src<span class="selector-class">.tar</span><span class="selector-class">.gz</span></div><div class="line">cd privoxy-<span class="number">3.0</span>.<span class="number">26</span>-stable</div></pre></td></tr></table></figure>
<p>privoxy-3.0.26-stable 是目前最新的稳定版，建议在下载前去 <a href="https://www.privoxy.org/sf-download-mirror/Sources/" target="_blank" rel="external">Privoxy 官网下载页</a> 检查一下版本。</p>
<h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><p>Privoxy 强烈不建议使用 root 用户运行，所以我们使用 <code>useradd privoxy</code> 新建一个用户.</p>
<h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">autoheader &amp;&amp; autoconf</div><div class="line">./configure</div><div class="line"><span class="built_in">make</span> &amp;&amp; <span class="built_in">make</span> install</div></pre></td></tr></table></figure>
<h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">vi <span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>privoxy<span class="regexp">/config</span></div></pre></td></tr></table></figure>
<p>找到以下两句，确保没有注释掉</p>
<figure class="highlight x86asm"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">listen-address <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">8118</span> # <span class="number">8118</span> 是默认端口，不用改，下面会用到</div><div class="line">forward-socks5t / <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">0</span> # 这里的端口写 shadowsocks 的本地端口</div></pre></td></tr></table></figure>
<h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">privoxy --<span class="keyword">user</span> <span class="title">privoxy</span> /usr/local/etc/privoxy/config</div></pre></td></tr></table></figure>
<h2 id="配置-etc-profile"><a href="#配置-etc-profile" class="headerlink" title="配置 /etc/profile"></a>配置 /etc/profile</h2><p>编辑：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">vi</span> /etc/<span class="keyword">profile</span></div></pre></td></tr></table></figure>
<p>添加下面两句：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> http_proxy=http:<span class="comment">//127.0.0.1:8118       #这里的端口和上面 privoxy 中的保持一致</span></div><div class="line"><span class="keyword">export</span> https_proxy=http:<span class="comment">//127.0.0.1:8118</span></div></pre></td></tr></table></figure>
<p>运行以下：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</div></pre></td></tr></table></figure>
<p>测试生效：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl www<span class="selector-class">.google</span><span class="selector-class">.com</span></div></pre></td></tr></table></figure>
<p>返回一大堆 HTML 则说明 shadowsocks 正常工作了。</p>
<h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果不能访问，请重启机器，依次打开 shadowsocks 和 privoxy 再测试.</p>
<figure class="highlight dts"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">nohup sslocal -c <span class="meta-keyword">/etc/</span>shadowsocks.json <span class="meta-keyword">/dev/</span>null <span class="number">2</span>&gt;<span class="variable">&amp;1</span> &amp;</div><div class="line">privoxy --user privoxy <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/etc/</span>privoxy/config</div></pre></td></tr></table></figure>
<p>如果不需要用代理了，记得把 <code>/etc/profile</code> 里的配置注释掉，不然会一直走代理流量。</p>
<hr>
<ul>
<li><a href="https://www.privoxy.org/" target="_blank" rel="external">Privoxy - Home Page</a></li>
<li><a href="https://zh.wikipedia.org/wiki/Shadowsocks" target="_blank" rel="external">Shadowsocks - Wikis</a></li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Shadowsocks </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
