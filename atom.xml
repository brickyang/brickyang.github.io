<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>全栈渐进之路</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://brickyang.github.io/"/>
  <updated>2019-03-31T09:57:38.672Z</updated>
  <id>http://brickyang.github.io/</id>
  
  <author>
    <name>Brick Yang</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Appropriate place for restaurant in Hong Kong</title>
    <link href="http://brickyang.github.io/2019/03/31/Appropriate-place-for-restaurant-in-Hong-Kong/"/>
    <id>http://brickyang.github.io/2019/03/31/Appropriate-place-for-restaurant-in-Hong-Kong/</id>
    <published>2019-03-31T09:35:06.000Z</published>
    <updated>2019-03-31T09:57:38.672Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1. Introduction"></a>1. Introduction</h2><h3 id="1-1-Background"><a href="#1-1-Background" class="headerlink" title="1.1. Background"></a>1.1. Background</h3><p>This is the capstone project of IBM Data Science Professional Certificate. In this project, I will use the Foursquare location data to explore neighborhoods in Hong Kong, and to come up with a problem that I can use the Foursquare location data to solve.</p><h3 id="1-2-Problem"><a href="#1-2-Problem" class="headerlink" title="1.2. Problem"></a>1.2. Problem</h3><p>I will explore the neighborhoods in Hong Kong and answer the question: “Where is the appropriate place to open a new restaurant in Hong Kong”.</p><h3 id="1-3-Interest"><a href="#1-3-Interest" class="headerlink" title="1.3. Interest"></a>1.3. Interest</h3><p>Hong Kong is one of the biggest international cities in the world, and one of the financial center of Asia. Opening a restaurant here is an attractive idea for any one who want to extends its business to Asia. They would be very interested in this project.</p><h2 id="2-Data"><a href="#2-Data" class="headerlink" title="2. Data"></a>2. Data</h2><h3 id="2-1-Data-Sources"><a href="#2-1-Data-Sources" class="headerlink" title="2.1. Data Sources"></a>2.1. Data Sources</h3><p>My main two data sources are:</p><ol><li>Wikipedia[1] provides the list of districts and neighborhoods in Hong Kong</li><li>Venues data from Foursquare[2]</li></ol><p>The coordinates data is from <a href="https://www.maps.ie/coordinates.html" target="_blank" rel="noopener">https://www.maps.ie/coordinates.html</a>.</p><p><em><strong>Note:</strong> Some data may contains Chinese characters, i.e. some places’ name, though I’ve tried my best to avoid it. Please aware that it doesn’t affect the analysis and report at all.</em></p><h3 id="2-2-Data-Cleaning"><a href="#2-2-Data-Cleaning" class="headerlink" title="2.2. Data Cleaning"></a>2.2. Data Cleaning</h3><p>Hong Kong consists of Hong Kong Island, the Kowloon Peninsula, the New Territories, Lantau Island, and over 200 other islands. This project will focus on Hong Kong Island and Kowloon.</p><p>First of all, I need to collect the districts and neighborhoods data from wikipedia page, and find the coordinates for every neighborhood. I did this manually and create a file named <code>neighborhoods_hong_kong.csv</code>.</p><p>The formatted data looks like this:</p><table><thead><tr><th style="text-align:left">District</th><th style="text-align:left">Neighborhood</th><th style="text-align:left">Latitude</th><th style="text-align:left">Longitude</th></tr></thead><tbody><tr><td style="text-align:left">Central &amp; Western</td><td style="text-align:left">Central District</td><td style="text-align:left">22.281322</td><td style="text-align:left">114.160258</td></tr><tr><td style="text-align:left">Central &amp; Western</td><td style="text-align:left">Mid-Levels</td><td style="text-align:left">22.282405</td><td style="text-align:left">114.145809</td></tr><tr><td style="text-align:left">Central &amp; Western</td><td style="text-align:left">The Peak</td><td style="text-align:left">22.272003</td><td style="text-align:left">114.152417</td></tr><tr><td style="text-align:left">Central &amp; Western</td><td style="text-align:left">Sai Wan</td><td style="text-align:left">22.285838</td><td style="text-align:left">114.134023</td></tr><tr><td style="text-align:left">Central &amp; Western</td><td style="text-align:left">Sheung Wan</td><td style="text-align:left">22.286870</td><td style="text-align:left">114.150267</td></tr></tbody></table><h3 id="2-3-Feature-Selection"><a href="#2-3-Feature-Selection" class="headerlink" title="2.3 Feature Selection"></a>2.3 Feature Selection</h3><p>In this project, I will get data of recommended venues inside 1000 meters radius of every neighborhood, calculate the top10 most common venues by its category as features. Plus, the 11th feature is if there is a bus/metro station nearby.</p><table><thead><tr><th style="text-align:left">Feature Label</th><th style="text-align:left">Type &amp; Description</th></tr></thead><tbody><tr><td style="text-align:left">1st Most Common Venue</td><td style="text-align:left">str. Name of the vanue category</td></tr><tr><td style="text-align:left">2nd Most Common Venue</td><td style="text-align:left">str</td></tr><tr><td style="text-align:left">3rd Most Common Venue</td><td style="text-align:left">str</td></tr><tr><td style="text-align:left">4th Most Common Venue</td><td style="text-align:left">str</td></tr><tr><td style="text-align:left">5th Most Common Venue</td><td style="text-align:left">str</td></tr><tr><td style="text-align:left">6th Most Common Venue</td><td style="text-align:left">str</td></tr><tr><td style="text-align:left">7th Most Common Venue</td><td style="text-align:left">str</td></tr><tr><td style="text-align:left">8th Most Common Venue</td><td style="text-align:left">str</td></tr><tr><td style="text-align:left">9th Most Common Venue</td><td style="text-align:left">str</td></tr><tr><td style="text-align:left">10th Most Common Venue</td><td style="text-align:left">str</td></tr><tr><td style="text-align:left">Station</td><td style="text-align:left">str. <code>Yes</code> or <code>No</code></td></tr></tbody></table><h2 id="3-Methodology"><a href="#3-Methodology" class="headerlink" title="3. Methodology"></a>3. Methodology</h2><h3 id="3-1-Explore-Dataset"><a href="#3-1-Explore-Dataset" class="headerlink" title="3.1. Explore Dataset"></a>3.1. Explore Dataset</h3><p>Using <code>folium</code> library to create map with markers to establish a global view of the dataset, and examine the accuracy of coordinates.</p><p><img src="https://raw.githubusercontent.com/brickyang/Coursera_Capstone/master/screenshot/map_with_markers.png" alt="map_with_markers"></p><p>It looks like every marker is in the right place. Markers cover almost whole Hong Kong Island and Kowloon. We can identify some famous place like Tsim Sha Tsui, Central District, and Causeway Bay.</p><h3 id="3-2-Examin-Foursquare-Location-Date"><a href="#3-2-Examin-Foursquare-Location-Date" class="headerlink" title="3.2. Examin Foursquare Location Date"></a>3.2. Examin Foursquare Location Date</h3><p>Using Foursquare’s <code>/venues/explore</code> API to get recommended vanues for a specific location. To simplify the results set the <code>limit</code> property is 100 and <code>radius</code> is 1000.</p><p>This request should returns a JSON data includes up to 100 venues for a coordinate.</p><p><img src="https://raw.githubusercontent.com/brickyang/Coursera_Capstone/master/screenshot/json_screenshot.png" alt="json_screenshot"></p><p>The result seems great. Next we can get venues for every neighborhoods.</p><h3 id="3-3-Pre-processing-Data"><a href="#3-3-Pre-processing-Data" class="headerlink" title="3.3. Pre-processing Data"></a>3.3. Pre-processing Data</h3><p>Firstly, use the venues data from Foursquare to create a <code>DataFrame</code>:</p><p><img src="https://raw.githubusercontent.com/brickyang/Coursera_Capstone/master/screenshot/vanues_dataframe.png" alt="vanues_dataframe"></p><p>Then create one-hot encoding to the vanues categories, get mean of each category for every neighborhood:</p><p><img src="https://raw.githubusercontent.com/brickyang/Coursera_Capstone/master/screenshot/onehot_neighborhood.png" alt="onehot_neighborhood"></p><p>Finally calculate the frequency of categories for each neighborhood, we get the top10 most common venues for every neighborhood:</p><p><img src="https://raw.githubusercontent.com/brickyang/Coursera_Capstone/master/screenshot/top10_venues.png" alt="top10_venues"></p><p>Plus, add a new column named ‘Station’ which represents if there is a bus/metro station nearby a neighborhood:</p><p><img src="https://raw.githubusercontent.com/brickyang/Coursera_Capstone/master/screenshot/final_dataframe.png" alt="final_dataframe"></p><p>Now the pre-processing step is finished. We can run clustering on it.</p><h3 id="3-4-Clustering"><a href="#3-4-Clustering" class="headerlink" title="3.4. Clustering"></a>3.4. Clustering</h3><p>For this project, k-means is an appropriate clustering algorithm. Because we have a unlabelled dataset, so this is an unsupervisied learning project. K-means clustering aims to partition <code>n</code> observations into <code>k</code> clusters in which each observation belongs to the cluster with the nearest mean.By clustering the neighborhoods, we can find out the pattern in them, identify the identical neighborhoods and see which is our target.</p><p>One difficulty of k-means is to determine the hyperparameter <code>k</code>. In this project I will choose <code>k=5</code>, means clustering the neighborhoods into 5 clusters. <code>k=5</code> is an experience hyperparameter.</p><h2 id="4-Results"><a href="#4-Results" class="headerlink" title="4. Results"></a>4. Results</h2><h3 id="4-1-Visualize-Clusters"><a href="#4-1-Visualize-Clusters" class="headerlink" title="4.1. Visualize Clusters"></a>4.1. Visualize Clusters</h3><p>Again, I use <code>folium</code> library to create a map with clustered markers:</p><p><img src="https://raw.githubusercontent.com/brickyang/Coursera_Capstone/master/screenshot/clustering_map.png" alt="img"></p><p>Obviously there are two main clusters. Almost all neighborhoods in these clusters located in the urban area which makes sense. The other three clusters seems located in the mountains. They are definitely not our target.</p><h3 id="4-2-Print-Clusters"><a href="#4-2-Print-Clusters" class="headerlink" title="4.2. Print Clusters"></a>4.2. Print Clusters</h3><p><strong>Cluster 1</strong></p><p><img src="https://raw.githubusercontent.com/brickyang/Coursera_Capstone/master/screenshot/cluster_1.png" alt="cluster_1"></p><p><strong>Cluster 2</strong></p><p><img src="https://raw.githubusercontent.com/brickyang/Coursera_Capstone/master/screenshot/cluster_2.png" alt="img"></p><p><strong>Cluster 3</strong></p><p><img src="https://raw.githubusercontent.com/brickyang/Coursera_Capstone/master/screenshot/cluster_3.png" alt="img"></p><p><strong>Cluster 4</strong></p><p><img src="https://raw.githubusercontent.com/brickyang/Coursera_Capstone/master/screenshot/cluster_4.png" alt="img"></p><p><strong>Cluster 5</strong></p><p><img src="https://raw.githubusercontent.com/brickyang/Coursera_Capstone/master/screenshot/cluster_5.png" alt="img"></p><h3 id="4-3-Answer-the-Question"><a href="#4-3-Answer-the-Question" class="headerlink" title="4.3. Answer the Question"></a>4.3. Answer the Question</h3><p>By examining the clusters, I identify the cluster 1 as residential area and cluster 2 represents commercial area.</p><p> The most common venues in cluster 1 are mostly Chinese restaurant (Cha Chaan Teng and Cantonese/Hong Kong restaurant are another types of Chinese restaurant), whereas the most common venues in cluster 2 are various, including foreign restaurants, fast food restaurants, gyms, clubs, and hotels.</p><p>Our question is “Where is the appropriate place to open a new restaurant”. The answer of this question depends on what type of the restaurant is. If it’s a local restaurant, neighborhoods in cluster 1 would be good places. But for upscale restaurant, neighborhoods in cluster 2 would be better choices.</p><h2 id="5-Discussion"><a href="#5-Discussion" class="headerlink" title="5. Discussion"></a>5. Discussion</h2><p>For this project, k-means works properly. we use the most common venues in neighborhood and bus/metro station as features, cluster the neighborhoods into 5 clusters. The result is good for our problem.</p><p>Although the result is accurate, we can also notice that the clusters is not precise enough. Adding more features like population and average income would be helpful.</p><h2 id="6-Conclusion"><a href="#6-Conclusion" class="headerlink" title="6. Conclusion"></a>6. Conclusion</h2><p>In this project, we need to use the location data from Foursquare to solve the problem “Where is the appropriate place to open a new restaurant in Hong Kong”.</p><p>I collect the neighborhoods data from wikipedia page, and format it manually. Get venues data using Foursquare’s API. One-hot encode the venues’ categories and calculate the frequencies, then get TOP10 common venues for each neighborhood plus the bus/metro station existence as features.</p><p>I use k-means algorithm to cluster the dataset into 5 clusters. I use <code>folium</code> library to visualize the cluster results. By examining the results, I could answer the question of this project.</p><p>In the future, more features could help to improve the model to get a better result.</p><h2 id="7-Refereences"><a href="#7-Refereences" class="headerlink" title="7. Refereences"></a>7. Refereences</h2><p>[1] <a href="https://en.wikipedia.org/wiki/List_of_places_in_Hong_Kong" target="_blank" rel="noopener">List of places in Hong Kong</a></p><p>[2] <a href="https://developer.foursquare.com/docs" target="_blank" rel="noopener">Foursquare API</a></p>]]></content>
    
    <summary type="html">
    
      Capstone project for IBM Data Science Professional Certificate in Coursera.
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://brickyang.github.io/tags/Machine-Learning/"/>
    
      <category term="Data Science" scheme="http://brickyang.github.io/tags/Data-Science/"/>
    
  </entry>
  
  <entry>
    <title>国内下载安装 Puppeteer 的方法</title>
    <link href="http://brickyang.github.io/2019/01/14/%E5%9B%BD%E5%86%85%E4%B8%8B%E8%BD%BD%E5%AE%89%E8%A3%85-Puppeteer-%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://brickyang.github.io/2019/01/14/国内下载安装-Puppeteer-的方法/</id>
    <published>2019-01-14T14:17:08.000Z</published>
    <updated>2019-01-14T14:44:24.899Z</updated>
    
    <content type="html"><![CDATA[<p>执行 <code>npm install puppeteer</code> 时，有可能会报错，也有可能不会。只要没看到类似：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Downloading Chromium r609904 - 82.7 Mb [===                 ] 16% 990.3s</span><br></pre></td></tr></table></figure><p>这样的输出，就是没有下载 Chromium。启动 app 后就会报错：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nodejs.Error: Chromium revision is not downloaded. Run <span class="string">"npm install"</span> or <span class="string">"yarn install"</span></span><br></pre></td></tr></table></figure><p>此时再执行这些命令通常没有用，因为能下载第一次安装时就会下载了。</p><h1 id="方法一（推荐）"><a href="#方法一（推荐）" class="headerlink" title="方法一（推荐）"></a>方法一（推荐）</h1><p>在终端执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PUPPETEER_DOWNLOAD_HOST=https://storage.googleapis.com.cnpmjs.org npm install puppeteer</span><br></pre></td></tr></table></figure><p>改用 cnpm 的镜像地址下载。此方法基本无副作用。</p><h1 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h1><p>改用 <code>puppeteer-cn</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save puppeteer-cn</span><br></pre></td></tr></table></figure><p>需要本地 Chrome 版本大于 59。详见：<a href="https://npm.taobao.org/package/puppeteer-cn" target="_blank" rel="noopener">puppeteer-cn</a></p><h1 id="方法三"><a href="#方法三" class="headerlink" title="方法三"></a>方法三</h1><p>用 cnpm 安装：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cnpm install puppeteer</span><br></pre></td></tr></table></figure><p>cnpm 是淘宝的镜像源，出于一些原因，我个人已经不再使用。关于 cnpm：<a href="https://github.com/cnpm/cnpm" target="_blank" rel="noopener">cnpm</a></p><h1 id="方法四"><a href="#方法四" class="headerlink" title="方法四"></a>方法四</h1><p>最复杂的手动安装，建议没事别折腾。参考：<a href="https://marxjiao.com/2018/08/26/puppeteer-install/" target="_blank" rel="noopener">手动下载 Chrome，解决 puppeteer 无法使用问题</a></p>]]></content>
    
    <summary type="html">
    
      因为某些原因国内难以正常安装 Puppeteer。
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Node.js 利用异步提升任务处理速度</title>
    <link href="http://brickyang.github.io/2019/01/06/Node-js-%E5%88%A9%E7%94%A8%E5%BC%82%E6%AD%A5%E6%8F%90%E5%8D%87%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E9%80%9F%E5%BA%A6/"/>
    <id>http://brickyang.github.io/2019/01/06/Node-js-利用异步提升任务处理速度/</id>
    <published>2019-01-06T10:05:51.000Z</published>
    <updated>2019-01-06T12:41:58.860Z</updated>
    
    <content type="html"><![CDATA[<p>今天在做一个小任务，需要调用阿里云的图像识别接口，对 62662 张照片进行场景识别，并将结果写到本地的 csv 文件中。</p><p>因为任务很简单，没想很多就开始码。自从有了 <code>async/await</code> 之后，已经很久不写 <code>callback</code> 了，所以上手就写成这样：</p><blockquote><p>本文所有代码均有简化，只保留关键过程</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> fetchSceneTags(imagePath) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> callAliyunAPI(imagePath);</span><br><span class="line">    <span class="keyword">return</span> result.errno === <span class="number">0</span> ? result.tags : [];</span><br><span class="line">&#125; <span class="keyword">catch</span>(error) &#123;</span><br><span class="line">    <span class="keyword">return</span> [];        </span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">writeScene</span>(<span class="params">paths</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>, len = paths.length; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">await</span> tags = fetchSceneTags(paths[i])</span><br><span class="line">        writeToFile(tags);</span><br><span class="line">        writeStdout(<span class="string">`<span class="subst">$&#123;i&#125;</span> / <span class="subst">$&#123;len&#125;</span>`</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> paths = loadPaths();</span><br><span class="line">    writeScene(paths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行起来以后没问题就放着忙别的去了。过了差不多 2 小时回来一看，才跑了 17180 张图，每分钟 144 张。这才意识到同步速度太慢了，于是停掉进程，将代码改成下面这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">fetchSceneTagsAsync(imagePath, callback) &#123;</span><br><span class="line">    callAliyunAPI(imagePath)</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tags = result.errno === <span class="number">0</span> ? result.tags : [];</span><br><span class="line">        callback(tags);</span><br><span class="line">    &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">error</span> =&gt;</span> callback([]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeSceneAsync</span>(<span class="params">paths</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="function"><span class="params">tags</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> tags = fetchSceneTagsAsync(paths[i])</span><br><span class="line">        writeToFile(tags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    paths.forEach(<span class="function"><span class="params">path</span> =&gt;</span> fetchSceneTagsAsync(path, callback));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> paths = loadPaths();</span><br><span class="line">    writeSceneAsync(paths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跑了一下，直接停摆了。嗯，不能一下把请求全发出去，加一个 Throttle：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">fetchSceneTagsAsync(imagePath, callback) &#123;</span><br><span class="line">    callAliyunAPI(imagePath)</span><br><span class="line">        .then(<span class="function"><span class="params">result</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> tags = result.errno === <span class="number">0</span> ? result.tags : [];</span><br><span class="line">        callback(tags);</span><br><span class="line">    &#125;)</span><br><span class="line">        .catch(<span class="function"><span class="params">error</span> =&gt;</span> callback([]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throttle</span>(<span class="params">paths, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(paths.length === <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> sub = paths.splice(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    sub.forEach(<span class="function"><span class="params">path</span> =&gt;</span> fetchSceneTagsAsync(path, callback));</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> throttle(paths, callback), <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">writeSceneAsync</span>(<span class="params">paths</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> callback = <span class="function"><span class="params">tags</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">await</span> tags = fetchSceneTagsAsync(paths[i])</span><br><span class="line">        writeToFile(tags);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    throttle(paths, callback)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">start</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> paths = loadPaths();</span><br><span class="line">    writeSceneAsync(paths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重新启动服务，观察了一下，大约每分钟处理 568 张图片，速度提升约 4 倍。</p>]]></content>
    
    <summary type="html">
    
      调用网络接口并将数据写入本地文件，异步过程的速度是同步过程的 4 倍以上。
    
    </summary>
    
    
      <category term="Node.js" scheme="http://brickyang.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>纯前端 Canvas 实现 HTML 转图片，自动生成微信阅读卡片</title>
    <link href="http://brickyang.github.io/2018/08/27/%E7%BA%AF%E5%89%8D%E7%AB%AF-Canvas-%E5%AE%9E%E7%8E%B0-HTML-%E8%BD%AC%E5%9B%BE%E7%89%87%EF%BC%8C%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E5%BE%AE%E4%BF%A1%E9%98%85%E8%AF%BB%E5%8D%A1%E7%89%87/"/>
    <id>http://brickyang.github.io/2018/08/27/纯前端-Canvas-实现-HTML-转图片，自动生成微信阅读卡片/</id>
    <published>2018-08-27T12:55:46.000Z</published>
    <updated>2019-01-06T09:50:14.465Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司微信公众号想使用 Apple 式的圆角阴影卡片做文章推荐。这种效果用 Adobe XD 可以轻松做出来，但是没法要求所有编辑都去学习新软件，所以就打算用前端实现一个小工具。效果如下：</p><p><strong>更新：</strong>已增加 Electron，可打包成 dmg 或 exe 文件运行。详见 <a href="https://github.com/brickyang/reading-card-generator" target="_blank" rel="noopener">GitHub</a>。</p><p><img src="https://github.com/brickyang/reading-card-generator/blob/master/screenshot.png?raw=true" alt="screenshot"></p><p>功能很简单，选择一张图片，输入标题文字，下载即可得到一张 PNG 格式透明背景的圆角阴影卡片图。核心的步骤有这几个：</p><ul><li>剪裁图片</li><li>HTML 转图片</li><li>生成圆角阴影样式</li></ul><p>其中关键一步 HTML 转图片，利用了著名的 <a href="https://github.com/niklasvh/html2canvas" target="_blank" rel="noopener">html2canvas</a> 库，其他几步都可以用 Canvas 轻松完成。</p><h2 id="剪裁图片"><a href="#剪裁图片" class="headerlink" title="剪裁图片"></a>剪裁图片</h2><p>为了简化功能，对选取的图片统一按 16:9 居中剪裁。</p><h3 id="获取图片文件"><a href="#获取图片文件" class="headerlink" title="获取图片文件"></a>获取图片文件</h3><p>从 <code>input</code> 获得 File 对象后，把它转成 Canvas 对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">listenFileInput</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> fileInput = <span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;INPUT_FILE_ID&#125;</span>`</span>);</span><br><span class="line">  fileInput.addEventListener(<span class="string">'change'</span>, ev =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> file = ev.target.files[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">const</span> image = <span class="keyword">new</span> Image();</span><br><span class="line">      </span><br><span class="line">    image.onload = loadImage;  <span class="comment">// 异步过程</span></span><br><span class="line">    </span><br><span class="line">    image.src = <span class="built_in">window</span>.URL.createObjectURL(file);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">loadImage</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> src = cropImage(<span class="keyword">this</span>);</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;CARD_IMAGE_ID&#125;</span>`</span>).src = src;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="剪裁"><a href="#剪裁" class="headerlink" title="剪裁"></a>剪裁</h3><p>利用 <code>.drawImage()</code> 将原图以剪裁模式「绘制」到新的 canvas 上，最后返回 base64 的图片地址，可直接用于 <code>&lt;img&gt;</code> 标签的 <code>src</code> 属性（见上一段代码末尾）。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cropImage</span>(<span class="params">image</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> width = image.width;</span><br><span class="line">  <span class="keyword">const</span> height = <span class="built_in">Math</span>.round(width * TARGET_RATIO);</span><br><span class="line">  <span class="keyword">const</span> cropX = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> cropY = <span class="built_in">Math</span>.round((image.height - height) / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> canvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">  canvas.width = width;</span><br><span class="line">  canvas.height = height;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> ctx = canvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  ctx.drawImage(image, cropX, cropY, width, height, <span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> canvas.toDataURL();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="HTML-to-Canvas"><a href="#HTML-to-Canvas" class="headerlink" title="HTML to Canvas"></a>HTML to Canvas</h2><p>直接利用 <code>html2canvas</code> 库。这个库目前在 GitHub 上有 13K+ star，最新的版本是 <code>1.0.0-alpha.12</code>，使用非常方便。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">generateScreenshot</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> htmlDom = <span class="built_in">document</span>.querySelector(<span class="string">`#<span class="subst">$&#123;HTML_ID&#125;</span>`</span>);</span><br><span class="line">  <span class="keyword">const</span> scale = getScale(); <span class="comment">// 因为手机和 PC 的像素比不同，HTML 转图片时要进行放大，否则在手机上图片会比较模糊，通常 3 倍左右即可</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// HTML 转 Canvas</span></span><br><span class="line">  <span class="keyword">const</span> origCanvas = <span class="keyword">await</span> html2canvas(htmlDom, &#123; scale &#125;);</span><br><span class="line">  <span class="comment">// 生成圆角图片</span></span><br><span class="line">  <span class="keyword">const</span> roundCanvas = drawRound(origCanvas, scale);</span><br><span class="line">  <span class="comment">// 生成阴影效果</span></span><br><span class="line">  <span class="keyword">return</span> drawShadow(roundCanvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="圆角阴影"><a href="#圆角阴影" class="headerlink" title="圆角阴影"></a>圆角阴影</h2><p>生成圆角矩形图片需要用到 Canvas 的 <code>.clip()</code> 方法，其作用是在 canvas 上只显示 clipping 区域内的内容。思路是先在 canvas 上画出一个圆角矩形，然后将上一步生成的图片「贴」进去。</p><p>由于经过 clip 的 canvas 只显示 clipping 区域内的内容，所以不能在这个 canvas 上直接给图片增加阴影，而是要将该 canvas 绘制到一个更大的 canvas 上，然后给这个圆角矩形的 canvas 增加阴影。</p><h3 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawRound</span>(<span class="params">origCanvas, scale</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> roundCanvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">  roundCanvas.width = DOM_WIDTH * scale;</span><br><span class="line">  roundCanvas.height = DOM_HEIGHT * scale;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> roundCtx = roundCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line">  <span class="keyword">const</span> roundRadius = RADIUS * scale;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在 canvas 上画出圆角矩形</span></span><br><span class="line">  <span class="keyword">const</span> x1 = roundRadius;</span><br><span class="line">  <span class="keyword">const</span> y1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">const</span> x2 = x1 + roundCanvas.width - <span class="number">2</span> * roundRadius;</span><br><span class="line">  <span class="keyword">const</span> y2 = y1;</span><br><span class="line">  <span class="keyword">const</span> x3 = x2 + roundRadius;</span><br><span class="line">  <span class="keyword">const</span> y3 = roundRadius;</span><br><span class="line">  <span class="keyword">const</span> x4 = x3;</span><br><span class="line">  <span class="keyword">const</span> y4 = y3 + roundCanvas.height - <span class="number">2</span> * roundRadius;</span><br><span class="line">  <span class="keyword">const</span> x5 = x2;</span><br><span class="line">  <span class="keyword">const</span> y5 = y4 + roundRadius;</span><br><span class="line">  <span class="keyword">const</span> x6 = x1;</span><br><span class="line">  <span class="keyword">const</span> y6 = y5;</span><br><span class="line">  <span class="keyword">const</span> x7 = x6 - roundRadius;</span><br><span class="line">  <span class="keyword">const</span> y7 = y4;</span><br><span class="line">  <span class="keyword">const</span> x8 = x7;</span><br><span class="line">  <span class="keyword">const</span> y8 = y3;</span><br><span class="line">  roundCtx.beginPath();</span><br><span class="line">  roundCtx.moveTo(x1, y1);</span><br><span class="line">  roundCtx.lineTo(x2, y2);</span><br><span class="line">  roundCtx.quadraticCurveTo(x3, y2, x3, y3);</span><br><span class="line">  roundCtx.lineTo(x4, y4);</span><br><span class="line">  roundCtx.quadraticCurveTo(x4, y5, x5, y5);</span><br><span class="line">  roundCtx.lineTo(x6, y6);</span><br><span class="line">  roundCtx.quadraticCurveTo(x7, y6, x7, y7);</span><br><span class="line">  roundCtx.lineTo(x8, y8);</span><br><span class="line">  roundCtx.quadraticCurveTo(x8, y1, x1, y1);</span><br><span class="line">    </span><br><span class="line">  <span class="comment">// 将图片「贴」进 clipping 区域，得到一个圆角矩形的图片</span></span><br><span class="line">  roundCtx.clip();</span><br><span class="line">  roundCtx.drawImage(origCanvas, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> roundCanvas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h3><p>根据阴影尺寸决定背景 canvas 的尺寸。最终下载的图片的尺寸，就是背景 canvas 的尺寸。设置太小，阴影会显示不完整；设置太大，则边缘留白空间太大，浪费空间且影响使用。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">drawShadow</span>(<span class="params">origCanvas</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> bgdCanvas = <span class="built_in">document</span>.createElement(<span class="string">'canvas'</span>);</span><br><span class="line">  bgdCanvas.width = origCanvas.width + MARGIN_WIDTH;</span><br><span class="line">  bgdCanvas.height = origCanvas.height + MARGIN_HEIGHT;</span><br><span class="line">  <span class="keyword">const</span> ctx = bgdCanvas.getContext(<span class="string">'2d'</span>);</span><br><span class="line"></span><br><span class="line">  ctx.shadowOffsetX = SHADOW_X;</span><br><span class="line">  ctx.shadowOffsetY = SHADOW_Y;</span><br><span class="line">  ctx.shadowBlur = SHADOW_BLUR;</span><br><span class="line">  ctx.shadowColor = SHADOW_COLOR;</span><br><span class="line">  ctx.drawImage(origCanvas, MARGIN_WIDTH / <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> bgdCanvas;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p>将做好的带有阴影的 canvas，通过 <code>.toDataURL()</code> 得到 base64 地址，设为 <code>&lt;a href=&quot;&quot; download /&gt;</code> 的 <code>href</code> 属性，即可下载使用。</p><blockquote><p>小工具的完整代码位于 GitHub：<a href="https://github.com/brickyang/reading-card-generator" target="_blank" rel="noopener">reading-card-generator</a>。</p></blockquote>]]></content>
    
    <summary type="html">
    
      利用 Canvas 将 HTML 转成图片，并具有自动截图、圆角阴影矩形等效果。
    
    </summary>
    
    
      <category term="前端" scheme="http://brickyang.github.io/tags/%E5%89%8D%E7%AB%AF/"/>
    
      <category term="Canvas" scheme="http://brickyang.github.io/tags/Canvas/"/>
    
  </entry>
  
  <entry>
    <title>利用 SSH 端口转发进行微信开发本地调试</title>
    <link href="http://brickyang.github.io/2018/06/16/%E5%88%A9%E7%94%A8-SSH-%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E8%BF%9B%E8%A1%8C%E5%BE%AE%E4%BF%A1%E5%BC%80%E5%8F%91%E6%9C%AC%E5%9C%B0%E8%B0%83%E8%AF%95/"/>
    <id>http://brickyang.github.io/2018/06/16/利用-SSH-端口转发进行微信开发本地调试/</id>
    <published>2018-06-16T02:25:23.000Z</published>
    <updated>2019-01-06T09:50:14.464Z</updated>
    
    <content type="html"><![CDATA[<p>使用微信 JS-SDK 进行网页开发时，微信要求绑定域名白名单，并仅接受该域名发起的请求，不便于本地开发调试。利用 SSH 端口转发可以解决这个问题。</p><p><strong>前提条件</strong></p><ul><li>一台服务器（云服务器或虚拟空间皆可，配置没要求，不需要运行服务）</li><li>一个域名（使用国内空间可能需要备案）</li></ul><p><strong>使用方法</strong></p><ol><li>域名解析至服务器</li><li>在微信后台绑定域名</li><li>在本地通过 SSH 将远程端口映射到本地</li></ol><p><strong>命令</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -R <span class="tag">&lt;<span class="name">REMOTE_PORT</span>&gt;</span>:127.0.0.1:<span class="tag">&lt;<span class="name">LOCAL_PORT</span>&gt;</span> <span class="tag">&lt;<span class="name">USER</span>&gt;</span>@<span class="tag">&lt;<span class="name">SERVER_IP</span>&gt;</span></span><br></pre></td></tr></table></figure><p>可以看到就是在 SSH 登录服务器的命令上，增加了 <code>-R</code> 参数，在远程端口和本地端口之间建立隧道，服务器上该端口的所有请求都会转发到本地端口上，实现了在本地接受公网请求进行调试的需要。</p><p><strong>Trouble Shooting</strong></p><p>如果登录服务器后看到：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ Warning: remote<span class="built_in"> port </span>forwarding failed <span class="keyword">for</span> listen<span class="built_in"> port </span>&lt;PORT&gt;</span><br></pre></td></tr></table></figure><p>说明服务器端口被占用，此时先登出服务器，重新普通登录（无端口转发）并关闭占用端口的进程：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh &lt;USER&gt;@&lt;SERVER_IP&gt;</span><br><span class="line">$ sudo netstat -plant | grep &lt;PORT&gt; // 查看哪些进程占用了端口</span><br><span class="line">$ <span class="built_in">kill</span> -9 &lt;PID&gt;</span><br><span class="line">$ ssh -R &lt;REMOTE_PORT&gt;:127.0.0.1:&lt;LOCAL_PORT&gt; &lt;USER&gt;@&lt;SERVER_IP&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      使用微信 JS-SDK 进行网页开发时，微信要求绑定域名白名单，并仅接受该域名发起的请求，不便于本地开发调试。利用 SSH 端口转发可以解决这个问题。
    
    </summary>
    
    
      <category term="SSH" scheme="http://brickyang.github.io/tags/SSH/"/>
    
      <category term="WeChat" scheme="http://brickyang.github.io/tags/WeChat/"/>
    
  </entry>
  
  <entry>
    <title>《计算机程序的构造和解释》（SICP）练习题解集</title>
    <link href="http://brickyang.github.io/2018/03/11/%E3%80%8A%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9E%84%E9%80%A0%E5%92%8C%E8%A7%A3%E9%87%8A%E3%80%8B%EF%BC%88SICP%EF%BC%89%E7%BB%83%E4%B9%A0%E9%A2%98%E8%A7%A3%E9%9B%86/"/>
    <id>http://brickyang.github.io/2018/03/11/《计算机程序的构造和解释》（SICP）练习题解集/</id>
    <published>2018-03-11T14:19:51.000Z</published>
    <updated>2019-01-06T09:50:14.463Z</updated>
    
    <content type="html"><![CDATA[<p>答案和代码位于 <a href="https://github.com/brickyang/sicp-solutions" target="_blank" rel="noopener">GitHub</a>：</p><ol><li><a href="https://github.com/brickyang/sicp-solutions/tree/master/chapter-1" target="_blank" rel="noopener">Chapter 1</a></li></ol><h2 id="安装-MIT-GNU-Scheme（macOS）"><a href="#安装-MIT-GNU-Scheme（macOS）" class="headerlink" title="安装 MIT/GNU Scheme（macOS）"></a>安装 MIT/GNU Scheme（macOS）</h2><p>下载：<a href="https://www.gnu.org/software/mit-scheme/" target="_blank" rel="noopener">https://www.gnu.org/software/mit-scheme/</a></p><ol><li>下载后运行 <code>.dmg</code> 文件，把 MIT/GNU Scheme.app 拖入 Applications 文件夹</li><li>在 Applications/应用程序 文件夹中找到 MIT/GNU Scheme，右键选择「显示包内容」</li><li>进入 /Contents/Resources/ 目录，双击 mit-scheme</li><li>看到如下图内容，运行成功</li></ol><p><img src="https://github.com/brickyang/sicp-solutions/blob/master/resources/mit-scheme-bash.png?raw=true" alt="mit-scheme-bash"></p><p>这就是 MIT/GNU Scheme 运行环境，我们可以在这里进行 Scheme 编程，完成习题。但是每次都要这样启动不太方便，所以我们做一个方便启动的软连接。</p><h3 id="设置软连接"><a href="#设置软连接" class="headerlink" title="设置软连接"></a>设置软连接</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ln -s /Applications/MIT\:GNU\ Scheme.app/Contents/Resources/mit-scheme /usr/<span class="built_in">local</span>/bin/scheme</span><br></pre></td></tr></table></figure><blockquote><p>由于 macOS 的安全机制，<code>/usr</code> 目录禁止设置软连接（包括管理员用户），只有 <code>/usr/local</code> 目录例外。</p></blockquote><h3 id="设置环境变量"><a href="#设置环境变量" class="headerlink" title="设置环境变量"></a>设置环境变量</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"export MITSCHEME_LIBRARY_PATH=\"/Applications/MIT\:GNU\ Scheme.app/Contents/Resources\""</span> &gt;&gt; ~/.bash_profile</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">"export MIT_SCHEME_EXE=\"/usr/local/bin/scheme\""</span> &gt;&gt; ~/.bash_profile</span><br><span class="line">$ <span class="built_in">source</span> ~/.bash_profile</span><br></pre></td></tr></table></figure><p>在终端中输入 <code>scheme</code> 命令，若正常启动 MIT/GNU Scheme 说明设置已生效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scheme</span><br></pre></td></tr></table></figure><p><img src="https://github.com/brickyang/sicp-solutions/blob/master/resources/mit-scheme-iterm2.png?raw=true" alt="mit-scheme-iterm2"></p><h2 id="一些快捷键"><a href="#一些快捷键" class="headerlink" title="一些快捷键"></a>一些快捷键</h2><ul><li><code>control + g</code>：跳出错误</li><li><code>control + z</code>：关闭 MIT/GNU Scheme</li></ul><h2 id="scm-文件"><a href="#scm-文件" class="headerlink" title="scm 文件"></a>scm 文件</h2><p>MIT/GNU Scheme 不支持光标移动，直接输入大量内容很不方便。一个简单的做法是将代码写在 <code>.scm</code> 文件中，然后运行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scheme -load &lt;filename&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      持续更新中……
    
    </summary>
    
    
      <category term="Lisp/Scheme" scheme="http://brickyang.github.io/tags/Lisp-Scheme/"/>
    
      <category term="Program" scheme="http://brickyang.github.io/tags/Program/"/>
    
  </entry>
  
  <entry>
    <title>Node.js 解决 csv 文件乱码的两种办法</title>
    <link href="http://brickyang.github.io/2018/03/10/Node-js-%E8%A7%A3%E5%86%B3-csv-%E6%96%87%E4%BB%B6%E4%B9%B1%E7%A0%81%E7%9A%84%E4%B8%A4%E7%A7%8D%E5%8A%9E%E6%B3%95/"/>
    <id>http://brickyang.github.io/2018/03/10/Node-js-解决-csv-文件乱码的两种办法/</id>
    <published>2018-03-10T15:56:57.000Z</published>
    <updated>2019-01-06T09:50:14.461Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题背景"><a href="#问题背景" class="headerlink" title="问题背景"></a>问题背景</h2><p>使用 Excel 打开 csv 文件出现乱码，通常是由于文件编码不匹配导致的。常见的两种编码：</p><ul><li>UTF-8：macOS 和 Node.js 环境的默认编码。macOS 和 Windows 的 Excel 打开是乱码。</li><li>GBK：macOS 和 Windows 的 Excel 打开可以正确显示。在 macOS 的「预览」中显示乱码。</li></ul><p>注意 Excel 在 macOS 和 Windows 的行为是一致的。所以 UTF-8 编码的 csv 文件在两个系统的 Excel 中都是乱码，GBK 在两个系统上都正常显示。</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><p>由上述结论可知，将 csv 文件保存为 GBK 编码，即可在两个系统的 Excel 中正确显示。Node.js 本身不支持 GBK 编码，可使用 <a href="iconv-lite">iconv-lite</a> 库。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> iconv <span class="keyword">from</span> <span class="string">'iconv-lite'</span>;</span><br><span class="line"></span><br><span class="line">fs.writeFileSync(filename, iconv.encode(str, <span class="string">'gbk'</span>));</span><br></pre></td></tr></table></figure><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>使用简单</li><li>macOS 和 Windows 的 Excel 都可以正常显示</li><li>Excel 兼容性好</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>不兼容 UTF-8 环境，比如 macOS 的「预览」中会显示乱码</li><li>Node.js 不支持 GBK</li></ul><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><p>Excel 并非不认识 UTF-8，而是不认识 UTF-8 without BOM。如果 UTF-8 文件带有 BOM 头，则 Excel 可以正确识别和打开。解法二就是给 csv 文件加上 BOM。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> fs <span class="keyword">from</span> <span class="string">'fs'</span>;</span><br><span class="line"></span><br><span class="line">fs.writeFileSync(filename, <span class="string">'\ufeff'</span>);</span><br><span class="line">fs.appendFileSync(filename, str);</span><br></pre></td></tr></table></figure><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><ul><li>优雅的 UTF-8 编码，兼容性广</li><li>Linux/Node.js 和 Excel 都可以正确打开</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><ul><li>低版本的 Excel 不支持</li></ul><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li>如果只考虑 Excel 的兼容性，尤其是重点考虑 Windows 平台，使用解法一；</li><li>如果解法一不能满足需要，且不用考虑低版本 Excel，使用解法二；</li><li>否则考虑使用 xlsx 文件。</li></ol>]]></content>
    
    <summary type="html">
    
      解决 csv 文件在 macOS 和 Windows 下使用 Excel 打开时中文出现乱码的问题。
    
    </summary>
    
    
      <category term="Node.js" scheme="http://brickyang.github.io/tags/Node-js/"/>
    
  </entry>
  
  <entry>
    <title>从 GitHub 到 GitLab，打造私有项目 CI/CD 工作流</title>
    <link href="http://brickyang.github.io/2018/01/04/%E4%BB%8E-GitHub-%E5%88%B0-GitLab%EF%BC%8C%E6%89%93%E9%80%A0%E7%A7%81%E6%9C%89%E9%A1%B9%E7%9B%AE-CI-CD-%E5%B7%A5%E4%BD%9C%E6%B5%81/"/>
    <id>http://brickyang.github.io/2018/01/04/从-GitHub-到-GitLab，打造私有项目-CI-CD-工作流/</id>
    <published>2018-01-04T04:17:07.000Z</published>
    <updated>2019-01-06T09:50:14.463Z</updated>
    
    <content type="html"><![CDATA[<p>一直用 GitHub 托管所有代码，包括一些非开源的商业项目，同时也一直在寻找最佳的 CI/CD 工作流配置。作为个人开发者，主要的需求有两个：</p><ol><li>不自建服务；</li><li>成本越低越好，最好免费。</li></ol><h2 id="GitHub-的不足"><a href="#GitHub-的不足" class="headerlink" title="GitHub 的不足"></a>GitHub 的不足</h2><p>GitHub 首先对私有仓库收费，新政策 7 美元/月还算便宜，比以前按仓库数量收费好得多。最主要的问题还是没有很合适的 CI/CD 服务。Travis CI 只对公开项目免费，对私有项目收费且价格不菲；CircleCI 对私有项目免费，但配置比较难用，也不是很满意。</p><h2 id="GitLab-的优势"><a href="#GitLab-的优势" class="headerlink" title="GitLab 的优势"></a>GitLab 的优势</h2><p>在试用了 GitLab 后发现以上问题都可以解决：</p><ol><li>无限制私有仓库</li><li>内置 CI/CD 服务，且配置简单易用，支持 Docker</li><li>内置私有的 Docker 仓库</li><li>免费</li></ol><p>我已经重新梳理了项目的开发-测试-部署流程，并把所有个人非开源项目都转移到 GitLab，把 GitHub 账户重新降级为 Free。</p><h2 id="工作流"><a href="#工作流" class="headerlink" title="工作流"></a>工作流</h2><p>我目前采用的工作流依托两个工具：</p><ol><li>Git：版本控制和管理</li><li>Docker：部署和运行应用</li></ol><p>我自己目前主要是个人开发，多人开发流程需要做一些调整。</p><ol><li>在本地 <code>dev</code> 分支上开发和单元测试</li><li>测试通过后，<code>merge</code> 到本地 <code>master</code> 分支</li><li>对 <code>master</code> 分支打 <code>tag</code>，<code>push</code> 到 GitLab</li><li>GitLab 自动进行构建和测试</li><li>测试通过后自动 <code>build image</code>，并将其 <code>push</code> 到 GitLab 提供的免费 Docker 仓库</li><li>手动登录服务器，<code>pull image</code>，替换 <code>container</code></li></ol><p>其中 4、5 两步在 GitLab 上自动完成，并且只对 tag 的推送进行操作。</p><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>这是一个 TypeScript 的 Node.js 项目的实例。</p><h3 id="gitlab-ci-yml"><a href="#gitlab-ci-yml" class="headerlink" title=".gitlab-ci.yml"></a>.gitlab-ci.yml</h3><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">build:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">build</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">node:8</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">install</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">tsc</span></span><br><span class="line"><span class="attr">  artifacts:</span></span><br><span class="line"><span class="attr">    paths:</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">node_modules/</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">app/**/*.js</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">app/*.js</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">config/*.js</span></span><br><span class="line"><span class="bullet">      -</span> <span class="string">app.js</span></span><br><span class="line"><span class="attr">    expire_in:</span> <span class="number">1</span> <span class="string">day</span></span><br><span class="line"></span><br><span class="line"><span class="attr">test:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">test</span></span><br><span class="line"><span class="attr">  image:</span> <span class="attr">node:8</span></span><br><span class="line"><span class="attr">  services:</span></span><br><span class="line"><span class="attr">    - redis:</span><span class="number">3.2</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">npm</span> <span class="string">run</span> <span class="string">test-ci</span></span><br><span class="line"></span><br><span class="line"><span class="attr">docker:</span><span class="attr">image:</span></span><br><span class="line"><span class="attr">  only:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">tags</span></span><br><span class="line"><span class="attr">  stage:</span> <span class="string">deploy</span></span><br><span class="line"><span class="attr">  image:</span> <span class="string">docker</span></span><br><span class="line"><span class="attr">  services:</span></span><br><span class="line"><span class="attr">    - docker:</span><span class="string">dind</span></span><br><span class="line"><span class="attr">  script:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">docker</span> <span class="string">version</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">docker</span> <span class="string">build</span> <span class="bullet">-t</span> <span class="string">$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME</span> <span class="string">.</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">echo</span> <span class="string">$GITLAB_USER_LOGIN</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">echo</span> <span class="string">$CI_JOB_TOKEN</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">echo</span> <span class="string">$CI_REGISTRY</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">docker</span> <span class="string">login</span> <span class="bullet">-u</span> <span class="string">gitlab-ci-token</span> <span class="bullet">-p</span> <span class="string">$CI_JOB_TOKEN</span> <span class="string">$CI_REGISTRY</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">docker</span> <span class="string">push</span> <span class="string">$CI_REGISTRY_IMAGE:$CI_COMMIT_REF_NAME</span></span><br></pre></td></tr></table></figure><p>GitLab 的 CI 过程分为多个 <code>job</code>，每个 <code>job</code> 彼此独立，可以实现复杂的 CI 过程，比如多环境并行测试。像这样一个简单的项目其实不需要分 <code>job</code>，因为每个 <code>job</code> 都要新建环境，浪费时间。</p><p>GitLab 的文档非常简单易懂，这里只说几个值得注意的点：</p><ol><li>在 <code>build</code> 中产生的文件（安装的依赖和编译文件），需要通过 <code>artifacts</code> 传递给后续的 <code>jobs</code>，否则后续 <code>jobs</code> 的环境中是没有这些文件的。</li><li>所有环境和数据库都在不同的 Docker <code>container</code> 中，所以连接数据库不能用 <code>Host: localhost</code>，而要用 <code>Host: redis</code>、<code>Host: mysql</code> 这种。</li><li><code>$CI_REGISTRY</code> 这种是 GitLab 的<a href="https://docs.gitlab.com/ce/ci/variables/README.html" title="GitLab CI/CD Variables" target="_blank" rel="noopener">预设变量</a>，可以直接使用。<code>$CI_JOB_TOKEN</code> 需要在设置页面先新建一个 Access Token。</li></ol><p>GitLab 提供了 <a href="https://gitlab.com/ci/lint" target="_blank" rel="noopener">CI Lint</a> 工具检查 <code>.gitlab-ci.yml</code> 文件的语法正确性。</p><h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>CI 的最后一步是 <code>build</code> Docker Image，所以要提供 Dockerfile 文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">FROM</span> <span class="attr">node:8.0</span></span><br><span class="line"></span><br><span class="line"><span class="string">RUN</span> <span class="string">echo</span> <span class="string">"Asia/Shanghai"</span> <span class="string">&gt; /etc/timezone</span></span><br><span class="line"><span class="string">RUN dpkg-reconfigure -f noninteractive tzdata</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RUN mkdir -p /app</span></span><br><span class="line"><span class="string">WORKDIR /app</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ADD node_modules /app/node_modules</span></span><br><span class="line"><span class="string">ADD app/*.js /app/app/</span></span><br><span class="line"><span class="string">ADD config/*.js /app/config/</span></span><br><span class="line"><span class="string">ADD app.js /app/app.js</span></span><br><span class="line"><span class="string">ADD package.json /app/package.json</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RUN cd /app</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">ENV NODE_ENV=production</span></span><br><span class="line"><span class="string">ENV PORT=3000</span></span><br><span class="line"><span class="string">EXPOSE 3000</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CMD ["npm", "start"]</span></span><br></pre></td></tr></table></figure><p>值得注意下的是 <a href="https://docs.docker.com/engine/reference/builder/#add" title="Dockerfile reference#ADD" target="_blank" rel="noopener"><code>ADD</code> 命令</a>，如果：</p><ol><li><code>ADD</code> 文件夹到目标位置，目标路径结尾没有 <code>/</code>：<code>ADD node_modules /app/node_modules</code></li><li><code>ADD</code> 多个文件到目标位置，目标路径结尾有 <code>/</code>：<code>ADD app/*.js /app/app/</code></li></ol><h2 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h2><p>目前发现这个过程唯一的缺点是，阿里云从 GitLab <code>pull image</code> 的网络连接很差，经常容易失败，比较考验 RP。这是阿里云的老问题了，对 GitHub 和 npm 的连接都很差。</p><p>如果对这一点不能忍受，可以选择其他 Docker 仓库，只需修改 <code>.gitlab-ci.yml</code> 的最后一句即可。</p><hr><ul><li><a href="https://docs.gitlab.com/ce/ci/yaml/README.html" target="_blank" rel="noopener">Configuration of your jobs with .gitlab-ci.yml</a></li><li><a href="https://docs.docker.com/engine/reference/builder/" target="_blank" rel="noopener">Dockerfile reference</a></li></ul>]]></content>
    
    <summary type="html">
    
      与 GitHub 相比，GitLab 内置对 CI/CD 的支持，而且对私有项目完全免费，更适合个人使用。
    
    </summary>
    
    
      <category term="Docker" scheme="http://brickyang.github.io/tags/Docker/"/>
    
      <category term="GitLab" scheme="http://brickyang.github.io/tags/GitLab/"/>
    
  </entry>
  
  <entry>
    <title>如何在 Egg.js 中使用 TypeScript</title>
    <link href="http://brickyang.github.io/2017/12/21/%E5%A6%82%E4%BD%95%E5%9C%A8-Egg-js-%E4%B8%AD%E4%BD%BF%E7%94%A8-TypeScript/"/>
    <id>http://brickyang.github.io/2017/12/21/如何在-Egg-js-中使用-TypeScript/</id>
    <published>2017-12-21T04:42:29.000Z</published>
    <updated>2019-01-13T12:11:42.159Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2019-01-13：</strong>本文发表时，Egg.js 还没有官方的 TypeScript 实践指南。目前 Egg 的 TypeScript 生态已经有了很大的改进，包括：</p><ul><li>egg-ts-helper 自动生成声明文件</li><li>内置 ts-node 实现开发阶段加载 <code>.ts</code> 文件并内存编译（不输出 <code>.js</code> 文件）</li><li><code>egg-init</code> 支持 <code>--type=ts</code></li><li>改进错误堆栈</li></ul><p>这些改进令使用 TypeScript 开发 Egg 应用更加方便。本文中提到的一些操作细节不再必要，不过这些概念仍然有效，对 TypeScript 新人也仍有价值。GitHub 上的 <a href="https://github.com/brickyang/egg-ts-boilerplate" target="_blank" rel="noopener">egg-ts-boilerplate</a> 也已经更新。</p><p>Egg.js 本身不是用 TypeScript 写的，但是它提供了 <code>index.d.ts</code> 文件，因此我们可以很方便地在自己的 Egg 应用中使用 TypeScript。</p><p>在 Egg.js 中使用 TypeScript 的模板：<a href="https://github.com/brickyang/egg-ts-boilerplate" target="_blank" rel="noopener">egg-ts-boilerplate</a>。</p><p>这个模板展示了如何用 TypeScript 写诸如 <code>controller</code>、<code>service</code>、配置、数据库、定时任务和扩展等 Egg 应用的概念。</p><p>本文是对这个模板的扩展阅读，主要是解释一些基本概念，帮助对 TypeScript 不是很熟悉的用户理解。</p><h2 id="TypeScript"><a href="#TypeScript" class="headerlink" title="TypeScript"></a>TypeScript</h2><p>TypeScript 的核心思想是，用 TypeScript 语法写 <code>.ts</code> 文件，然后由编译器将其编译成 <code>.js</code> 文件。根据 TypeScript 语法，如果你使用了一个类，就需要先声明它，否则编译器「不认识」它，就无法通过编译。</p><p>在自己的 Egg 应用中使用 TypeScript，核心就是「如何让编译器认识 Egg 库中的类」，解决方法就是 <code>index.d.ts</code>。</p><h2 id="index-d-ts"><a href="#index-d-ts" class="headerlink" title="index.d.ts"></a>index.d.ts</h2><p>在 Egg 中用 TypeScript，其实关键就是 <code>index.d.ts</code> 文件。</p><p><code>index.d.ts</code> 就像 C/C++ 中的 <code>.h</code> 文件。它的作用可以简单理解为就是声明类和库的 API。</p><p>虽然 Egg 不是用 TypeScript 写的，但是它提供了 <code>index.d.ts</code> 文件，因此当你在自己的应用中 <code>import xxx from &#39;egg&#39;</code> 时，编译器知道如何处理。</p><p>在 Egg 中使用 TypeScript 的第一个核心问题：Egg 的 <code>index.d.ts</code> 文件，Egg 的作者和社区已经帮我们解决了（虽然还不是很完善）。</p><p>第二个问题是：我们应用中的 <code>controller</code> 和 <code>service</code> 等，是从 Egg 的 <code>Controller</code> 、<code>Service</code> 等类继承来的。这些自定义内容在 Egg 的 <code>index.d.ts</code> 中是没有的，所以需要写在<strong>自己的</strong> <code>index.d.ts</code> 文件中。</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// egg-ts-boilerplate/index.d.ts</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">declare</span> <span class="keyword">module</span> 'egg' &#123;</span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> Application &#123;</span><br><span class="line">    config: EggAppConfig &amp; DefaulConfig;</span><br><span class="line">    bar: <span class="built_in">string</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> IController &#123;</span><br><span class="line">    home: HomeController;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">export</span> <span class="keyword">interface</span> IService &#123;</span><br><span class="line">    home: HomeService;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 <code>egg-ts-boilerplate</code> 的 <code>index.d.ts</code>。现在编译器就「认识」<code>app.config</code>、<code>app.bar</code>、<code>controller.home</code> 和 <code>service.home</code> 了。</p><p>基本上，理解并搞定 <code>index.d.ts</code>，就可以自由地用 TypeScript 写 Egg 应用了。</p><h2 id="模块解析策略"><a href="#模块解析策略" class="headerlink" title="模块解析策略"></a>模块解析策略</h2><p>熟悉 TypeScript 的模块解析策略有助于在遇到 <code>not found module</code> 错误时排查问题。</p><p>TypeScript 支持两种策略：<code>class</code> 和 <code>node</code>。<code>egg-ts-boilerplate</code> 使用的是 <code>node</code> 模式（在 <code>.tsconfig.json</code> 中定义）。</p><p>其解析顺序与 Node.js 类似。假设在 <code>/root/src/moduleA.ts</code> 中 <code>import &#39;moduleB&#39;</code>，则解析顺序是：</p><ol><li><code>/root/src/node_modules/moduleB.ts</code></li><li><code>/root/src/node_modules/moduleB.tsx</code></li><li><code>/root/src/node_modules/moduleB.d.ts</code></li><li><code>/root/src/node_modules/moduleB/package.json</code> 中的 <code>types</code> 属性</li><li><code>/root/src/node_modules/moduleB/index.ts</code></li><li><code>/root/src/node_modules/moduleB/index.tsx</code></li><li><code>/root/src/node_modules/moduleB/index.d.ts</code></li><li><code>/root/node_modules/moduleB.ts</code></li><li><code>/root/node_modules/moduleB.tsx</code></li><li><code>/root/node_modules/moduleB.d.ts</code></li><li><code>/root/node_modules/moduleB/package.json</code> 中的 <code>types</code> 属性</li><li><code>/root/node_modules/moduleB/index.ts</code></li><li><code>/root/node_modules/moduleB/index.tsx</code></li><li><code>/root/node_modules/moduleB.index.d.ts</code></li><li><code>/node_modules/moduleB.ts</code></li><li><code>/node_modules/moduleB.tsx</code></li><li><code>/node_modules/moduleB.d.ts</code></li><li><code>/node_modules/moduleB/package.json</code> 中的 <code>types</code> 属性</li><li><code>/node_modules/moduleB/index.ts</code></li><li><code>/node_modules/moduleB/index.tsx</code></li><li><code>/node_modules/moduleB/index.d.ts</code></li></ol><p>基本思路就是先查找同名文件，如果没有就把模块名当文件夹处理。如果所有路径都找不到，就会抛出 <code>not found</code> 错误。</p><p>注意这里 <code>import &#39;moduleB&#39;</code> 是非相对路径。如果是相对路径，则会按照指定路径去解析。</p><p>详细说明可以阅读文档：<a href="https://www.typescriptlang.org/docs/handbook/module-resolution.html" target="_blank" rel="noopener">Module Resolution</a></p><h2 id="编译文件的位置"><a href="#编译文件的位置" class="headerlink" title="编译文件的位置"></a>编译文件的位置</h2><p>通常使用 TypeScript 时，会把 <code>.ts</code> 文件放在 <code>/src</code> 文件夹，然后把编译得到的 <code>.js</code> 文件放在 <code>/build</code> 文件夹，应用实际运行的是 <code>/build</code> 文件夹中的 <code>.js</code> 文件。</p><p>Egg 对应用文件夹结构有强制性要求，所以在 <code>.tsconfig.json</code> 中没有指定输出文件夹，因此编译得到的 <code>.js</code> 文件会和 <code>.ts</code> 文件位于同目录下。</p><p>如果你使用 VSCode，编译后在 Explorer 中是看不到 <code>.js</code> 文件的（在 Finder 中可以看到）。因为在 <code>/.vscode/setting.json</code> 中设置了 <code>.js</code> 文件不可见（同时不可见的还有 <code>node_module/</code> 等）。如果你使用其他编辑器，可以做相应设置。</p>]]></content>
    
    <summary type="html">
    
      Egg.js 本身不是用 TypeScript 写的，但是你可以自由地在自己的 Egg 应用中使用 TypeScript。
    
    </summary>
    
    
      <category term="Egg.js" scheme="http://brickyang.github.io/tags/Egg-js/"/>
    
      <category term="TypeScript" scheme="http://brickyang.github.io/tags/TypeScript/"/>
    
  </entry>
  
  <entry>
    <title>利用 AWS 搭建 Tensoflow + Keras 深度学习环境</title>
    <link href="http://brickyang.github.io/2017/12/18/%E5%88%A9%E7%94%A8-AWS-%E6%90%AD%E5%BB%BA-Tensoflow-Keras-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%8E%AF%E5%A2%83/"/>
    <id>http://brickyang.github.io/2017/12/18/利用-AWS-搭建-Tensoflow-Keras-深度学习环境/</id>
    <published>2017-12-18T13:31:35.000Z</published>
    <updated>2019-01-06T09:50:14.463Z</updated>
    
    <content type="html"><![CDATA[<p>Amazon Web Services（AWS）非常适合用来学习深度学习。其最便宜的 GPU 计算实例 p2.xlarge 基本价格最低仅 0.9 美元/小时，如果使用竞价（Spot）实例则价格还有可能更低。在你决定出手 1080 Ti 之前，不妨先用 AWS 来练习。</p><p>在 AWS 上搭建一个深度学习环境非常简单，但对没有经验的新手来说还是存在一些小坑的。本文记录了我搭建环境的过程。我的环境是 Ubuntu 16.04、Python 3.5、Tensorflow 1.4、Keras 2.1、CUDA 8、cuDNN 6 以及 Jupyter Notebook。</p><h2 id="启动-AWS-实例"><a href="#启动-AWS-实例" class="headerlink" title="启动 AWS 实例"></a>启动 AWS 实例</h2><blockquote><p>AWS 地址：<a href="https://aws.amazon.com" target="_blank" rel="noopener">https://aws.amazon.com</a></p></blockquote><p>AWS 提供了大量的产品，我们需要的是 Amazon EC2，即「虚拟服务器」。在开始搭建环境前需要先启动一个「实例」。可以简单地将「实例」理解为服务器。启动一个实例即为「购买」一台服务器。</p><p>AWS 后台可以使用美亚账号登录，如果没有就注册一个吧。登录后台后，进入 EC2 服务控制面板。此时先注意一下页面右上角，在你的 ID 右边应该显示当前服务的区域，建议选择亚太的「东京」区域。我在北京联通光纤宽带的环境下实测，东京线路的速度很不错。</p><blockquote><p>AWS 提供了多个区域供选择，包括美国、亚太、欧洲等。不同地区的实例和 AMI（映像）互不相通，大陆用户建议首选「亚太区域（东京）」。</p></blockquote><p>选好地区后即可「启动实例」。首先需要选择 AMI。因为我们要自己搭建环境，所以这里选择「快速启动」中的「Ubuntu Server 16.04 LTS (HVM), SSD Volume Type」。</p><blockquote><p>你也可以在「社区 AMI」中搜索「ami-ef0a8489」，直接使用我已经装好环境的 AMI，则本文到此为止。</p></blockquote><p>创建实例过程中注意三点：</p><ol><li>选择「p2.xlarge」实例。p2.xlarge 拥有一块 Nvidia Tesla K80 显卡，应付一般的 DL 的学习，包括参加 Kaggle 的竞赛都够了；</li><li>AWS 会要求你创建一个 SSH Key，起个简单的名字即可。将下载的 <code>.pem</code> 文件放在 <code>~/.ssh</code> 目录下，这是你的登录凭证；</li><li>注意「安全组」。默认的安全组是禁止一切访问的，将「入站规则」的「来源」设为「任何位置」，否则可能无法登录（如果你知道自己在做什么，则请随意设置）。</li></ol><p>等待实例启动后，使用 SSH 登录服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -i ~/.ssh/&lt;filename&gt;.pem ubuntu@&lt;公有 IP&gt;</span><br></pre></td></tr></table></figure><h3 id="收费"><a href="#收费" class="headerlink" title="收费"></a>收费</h3><p>p2.xlarge 的标准费用和地区有关。弗吉尼亚北部最低，0.9 美元/小时，东京是 1.542 美元/小时，启动即开始计费，停机则停止计费。因此如果你每次使用时间不长，使用完毕记得「停止」即可，费用很低。</p><p>如果你需要长期使用（比如需要训练一个大模型），强烈建议使用「竞价请求」，通常情况下不会超过 0.5 美元/小时。关于竞价请求的介绍可以看这里：<a href="https://aws.amazon.com/ec2/spot/" target="_blank" rel="noopener">https://aws.amazon.com/ec2/spot/</a></p><h2 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h2><h3 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h3><p>使用基础 AMI 启动的实例安装了 Ubuntu 16.4 系统和 Python 3.5。第一步需要安装显卡驱动。</p><p>下载地址：<a href="http://www.nvidia.com/download/driverResults.aspx/122825/en-us" target="_blank" rel="noopener">http://www.nvidia.com/download/driverResults.aspx/122825/en-us</a></p><p>下载好驱动后将文件上传到服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp -i ~/.ssh/&lt;filename&gt;.pem ~/downloads/&lt;driver&gt;.deb ubuntu@&lt;IP&gt;:~</span><br></pre></td></tr></table></figure><p>这个命令将 <code>&lt;driver&gt;.deb</code> 文件上传到服务器的 <code>~</code> 目录（在上一步登录服务器后，你应该已经在这个目录中了）。</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ./&lt;driver&gt;.deb</span><br></pre></td></tr></table></figure><p>等待安装完毕即可。</p><h3 id="验证安装"><a href="#验证安装" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装完成后，运行 <code>nvidia-smi</code> 命令，看到显卡信息则说明安装成功。</p><h2 id="安装-CUDA-8"><a href="#安装-CUDA-8" class="headerlink" title="安装 CUDA 8"></a>安装 CUDA 8</h2><p>目前最新的 CUDA 是 9.0，但 Tensorflow 仍然使用 CUDA 8，所以<strong>一定要安装 CUDA 8</strong>，否则使用 Tensorflow 时会报错。</p><h3 id="下载-1"><a href="#下载-1" class="headerlink" title="下载"></a>下载</h3><p>下载地址：<a href="https://developer.nvidia.com/cuda-80-ga2-download-archive" target="_blank" rel="noopener">https://developer.nvidia.com/cuda-80-ga2-download-archive</a></p><p>在这个页面，依次选择「Linux」，「x86_64」，「Ubuntu」，「16.04」，「deb (network)」。将下载得到的文件上传到服务器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ scp -i ~/.ssh/&lt;filename&gt;.pem ~/downloads/cuda-repo-ubuntu1604_8.0.61-1_amd64.deb.deb ubuntu@&lt;IP&gt;:~</span><br></pre></td></tr></table></figure><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ./cuda-repo-ubuntu1604_8.0.61-1_amd64.deb.deb</span><br></pre></td></tr></table></figure><h3 id="验证安装-1"><a href="#验证安装-1" class="headerlink" title="验证安装"></a>验证安装</h3><p>安装完成后应该会看到 <code>/usr/local/cuda-8.0</code> 目录。</p><h2 id="安装-cuDNN"><a href="#安装-cuDNN" class="headerlink" title="安装 cuDNN"></a>安装 cuDNN</h2><p>cuDNN 也有一个小坑：其最新版本是 7，但<strong>一定要安装 cuDNN 6</strong>，否则会报错。</p><h3 id="下载-2"><a href="#下载-2" class="headerlink" title="下载"></a>下载</h3><p>下载 cuDNN 需要注册 Nvidia Developer 账号并登录。在下载页（<a href="https://developer.nvidia.com/rdp/cudnn-download）勾选「I" target="_blank" rel="noopener">https://developer.nvidia.com/rdp/cudnn-download）勾选「I</a> Agree……」即可看到下载列表，谨记选择「Download cuDNN v6.0 (April 27, 2017), for CUDA 8.0」，有三个文件：</p><ol><li><code>cuDNN v6.0 Runtime Library for Ubuntu16.04 (Deb)</code></li><li><code>cuDNN v6.0 Developer Library for Ubuntu16.04 (Deb)</code></li><li><code>cuDNN v6.0 Code Samples and User Guide for Ubuntu16.04 (Deb)</code></li></ol><p>依次下载并上传即可。</p><h3 id="安装-2"><a href="#安装-2" class="headerlink" title="安装"></a>安装</h3><p>使用同样的命令依次安装三个文件。</p><h3 id="验证安装-2"><a href="#验证安装-2" class="headerlink" title="验证安装"></a>验证安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo find / -name libcudnn*</span><br></pre></td></tr></table></figure><p>可以看到一系列 <code>libcudnn6</code> 的相关文件。</p><h2 id="安装-Tensorflow"><a href="#安装-Tensorflow" class="headerlink" title="安装 Tensorflow"></a>安装 Tensorflow</h2><p>默认环境安装了 Python 3.5 但是没有安装 <code>pip3</code>，所以我们先安装它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install python3-pip python3-dev</span><br></pre></td></tr></table></figure><p>然后安装 Tensorflow：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install tensorflow-gpu</span><br></pre></td></tr></table></figure><h3 id="验证安装-3"><a href="#验证安装-3" class="headerlink" title="验证安装"></a>验证安装</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ python3</span><br><span class="line">&gt;&gt;&gt; import tensorflow</span><br></pre></td></tr></table></figure><p>通常这里如果没有报错，就说明 Tensorflow 已经正确安装了。</p><blockquote><p>参考资料：<a href="https://www.tensorflow.org/install/install_linux#InstallingNativePip" target="_blank" rel="noopener">Installing TensorFlow on Ubuntu</a></p></blockquote><h2 id="安装-Keras"><a href="#安装-Keras" class="headerlink" title="安装 Keras"></a>安装 Keras</h2><p>安装 Keras 比较简单，直接 <code>pip3</code> 安装即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ pip3 install keras</span><br><span class="line">$ pip3 install jupyter notebook</span><br></pre></td></tr></table></figure><h2 id="安装-Jupyter-Notebook"><a href="#安装-Jupyter-Notebook" class="headerlink" title="安装 Jupyter Notebook"></a>安装 Jupyter Notebook</h2><p>Jupyter 官方建议使用 Anaconda，这也是我们通常推荐使用环境。不过因为我们使用 AWS 通常只是针对特定的项目，而且是临时性使用，可以把整个实例看作一个隔离的环境，所以就不使用 Anaconda 而直接安装了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m pip install jupyter</span><br></pre></td></tr></table></figure><h2 id="安装常用库（可选）"><a href="#安装常用库（可选）" class="headerlink" title="安装常用库（可选）"></a>安装常用库（可选）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip3 install numpy pandas scikit-learning pillow h5py openvc-python</span><br></pre></td></tr></table></figure><h2 id="开始项目"><a href="#开始项目" class="headerlink" title="开始项目"></a>开始项目</h2><p>现在我们已经安装好了基本环境，你可以继续根据需要安装其他包，例如 <code>numpy</code>、<code>pandas</code> 等。要开始项目，只需要启动 Jupyter Notebook 即可：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jupyter notebook --ip=0.0.0.0</span><br></pre></td></tr></table></figure><p>然后就可以在本地浏览器打开 <code>&lt;IP&gt;:8888</code> 访问服务器上的 notebook，开始愉快地开发了。不过通常建议先在本地开发，确定程序没问题后，再到服务器上进行训练，毕竟服务器是按时间收费。</p><hr><ul><li><a href="https://www.tensorflow.org/install/install_linux#InstallingNativePip" target="_blank" rel="noopener">Installing TensorFlow on Ubuntu</a></li><li><a href="https://keras.io/#installation" target="_blank" rel="noopener">Keras Documentation#Installation</a></li><li><a href="http://jupyter.org/install.html" target="_blank" rel="noopener">Installing Jupyter</a></li></ul>]]></content>
    
    <summary type="html">
    
      利用 AWS 快速搭建完整的深度学习环境，以极低成本享受 GPU 计算的快感。本文使用 Ubuntu 16.04、Python 3.5、Tensorflow 1.4、Keras 2.1、CUDA 8，cuDNN 6 环境。
    
    </summary>
    
    
      <category term="DeepLearning" scheme="http://brickyang.github.io/tags/DeepLearning/"/>
    
      <category term="Tensorflow" scheme="http://brickyang.github.io/tags/Tensorflow/"/>
    
      <category term="Keras" scheme="http://brickyang.github.io/tags/Keras/"/>
    
  </entry>
  
  <entry>
    <title>egg-mongo-native，基于 MongoDB Native Driver</title>
    <link href="http://brickyang.github.io/2017/07/04/egg-mongo-native%EF%BC%8C%E5%9F%BA%E4%BA%8E-MongoDB-Native-Driver/"/>
    <id>http://brickyang.github.io/2017/07/04/egg-mongo-native，基于-MongoDB-Native-Driver/</id>
    <published>2017-07-04T08:23:05.000Z</published>
    <updated>2019-01-06T09:50:14.462Z</updated>
    
    <content type="html"><![CDATA[<p><strong>2017/12/18 更新</strong> egg-mongo-native 已升级至 Egg.js 2 并支持集群配置。</p><hr><p>MongoDB 官方为 Node.js 提供了 MongoDB Native Driver。这也是我一直喜欢使用的 MongoDB 库。直接使用官方 API 简单明了，而且也易于学习。</p><p>Egg.js 官方提供的 MongoDB 插件基于 Mongoose，所以就自己动手做了这个插件。插件的 API 都是我在实际项目中长期使用的。</p><p><strong>GitHub：</strong><a href="https://github.com/brickyang/egg-mongo-native" target="_blank" rel="noopener">https://github.com/brickyang/egg-mongo-native</a></p><p>本插件基于 <a href="https://github.com/mongodb/node-mongodb-native" target="_blank" rel="noopener">node-mongodb-native</a>，提供了 MongoDB 官方 driver 及 API。</p><p>插件对一些常用 API 进行了简单封装以简化使用，同时保留了所有原版属性。例如，使用原版 API 进行一次查找需要写</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">'name'</span>)</span><br><span class="line"> .find(query)</span><br><span class="line"> .skip(skip)</span><br><span class="line"> .limit(limit)</span><br><span class="line"> .project(project)</span><br><span class="line"> .sort(sort)</span><br><span class="line"> .toArray();</span><br></pre></td></tr></table></figure><p>封装后</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">app.mongo.find(<span class="string">'name'</span>, &#123; query, skip, limit, project, sort &#125;);</span><br></pre></td></tr></table></figure><p>此插件完全支持 Promise，并强烈推荐使用 async/await。</p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm i egg-mongo-native --save</span><br></pre></td></tr></table></figure><h2 id="开启插件"><a href="#开启插件" class="headerlink" title="开启插件"></a>开启插件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// config/plugin.js</span></span><br><span class="line">exports.mongo = &#123;</span><br><span class="line">  enable: <span class="literal">true</span>,</span><br><span class="line">  package: <span class="string">'egg-mongo-native'</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><h3 id="单实例"><a href="#单实例" class="headerlink" title="单实例"></a>单实例</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// &#123;app_root&#125;/config/config.default.js</span></span><br><span class="line">exports.mongo = &#123;</span><br><span class="line">  client: &#123;</span><br><span class="line">    host: <span class="string">'host'</span>,</span><br><span class="line">    port: <span class="string">'port'</span>,</span><br><span class="line">    name: <span class="string">'test'</span>,</span><br><span class="line">    user: <span class="string">'user'</span>,</span><br><span class="line">    password: <span class="string">'password'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="集群-（v2-1-0-以上）"><a href="#集群-（v2-1-0-以上）" class="headerlink" title="集群 （v2.1.0 以上）"></a>集群 （v2.1.0 以上）</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mongodb://host1:port1,host2:port2/name?replicaSet=test</span></span><br><span class="line">exports.mongo = &#123;</span><br><span class="line">  client: &#123;</span><br><span class="line">    host: <span class="string">'host1, host2'</span>,</span><br><span class="line">    port: <span class="string">'port1, port2'</span>,</span><br><span class="line">    name: <span class="string">'name'</span>,</span><br><span class="line">    option: &#123;</span><br><span class="line">      replicaSet: <span class="string">'test'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mongodb://host:port1,host:port2/name?replicaSet=test</span></span><br><span class="line">exports.mongo = &#123;</span><br><span class="line">  client: &#123;</span><br><span class="line">    host: <span class="string">'host'</span>, <span class="comment">// or ['host']</span></span><br><span class="line">    port: <span class="string">'port1, port2'</span>, <span class="comment">// or ['port1', 'port2']</span></span><br><span class="line">    name: <span class="string">'name'</span>,</span><br><span class="line">    option: &#123;</span><br><span class="line">      replicaSet: <span class="string">'test'</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>请到 <a href="config/config.default.js">config/config.default.js</a> 查看详细配置项说明。</p><h2 id="使用示例"><a href="#使用示例" class="headerlink" title="使用示例"></a>使用示例</h2><p>本插件提供的 API 只是对原版 API 进行了必要的简化，所有属性名称与原版 API 一致。所有针对文档操作的 API，通常接受 2 个参数，第一个参数是 collection 名称，第二个参数是一个对象，属性名即为原版 API 的所有参数。例如，使用原版 API 进行一次插入</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">db.collection(<span class="string">'name'</span>).insertOne(doc, options);</span><br></pre></td></tr></table></figure><p>使用插件 API</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> args = &#123; doc, options &#125;;</span><br><span class="line">app.mongo.insertOne(<span class="string">'name'</span>, args);</span><br></pre></td></tr></table></figure><p>可以看到 <code>args</code> 就是包含原版 API 参数的一个对象。</p><p>目前插件提供的 API 包括：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">connect()      <span class="comment">// 不需要用户调用</span></span><br><span class="line">insertOne()</span><br><span class="line">findOneAndUpdate()</span><br><span class="line">findOneAndReplace()</span><br><span class="line">findOneAndDelete()</span><br><span class="line">insertMany()</span><br><span class="line">updateMany()</span><br><span class="line">deleteMany()</span><br><span class="line">find()</span><br><span class="line">count()</span><br><span class="line">distinct()</span><br><span class="line">createIndex()</span><br><span class="line">listCollection()</span><br><span class="line">createCollection()</span><br></pre></td></tr></table></figure><p>当然，在任何时候你也都可以使用 <code>app.mongo.db</code> 调用所有 API。你可以在这里查看所有 API：<a href="http://mongodb.github.io/node-mongodb-native/2.2/api/" target="_blank" rel="noopener">Node.js MongoDB Driver API</a>。</p><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p><code>node-mongodb-native</code> 所有 API 都支持 Promise，因此你可以自由地以异步或同步方式使用本插件。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Promise</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  app.mongo.insertOne(<span class="string">'name'</span>, &#123; doc &#125;)</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.error(error));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 async/await</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">doc</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">await</span> app.mongo.insertOne(<span class="string">'name'</span>, &#123; doc &#125;);</span><br><span class="line">    <span class="built_in">console</span>.log(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你使用 <code>app.mongo.db</code> 调用原版 API，则也可以使用回调函数。插件封装的 API 不支持回调函数，因为 Promise 和 async/await 更加优雅。</p><p>Node.js 7.6 开始已经原生支持 async/await，不再需要 Babel。</p><h2 id="License"><a href="#License" class="headerlink" title="License"></a>License</h2><p><a href="https://github.com/brickyang/egg-mongo/blob/master/LICENSE" target="_blank" rel="noopener">MIT</a></p>]]></content>
    
    <summary type="html">
    
      本插件基于 node-mongodb-native，提供了 MongoDB 官方 driver 及 API。插件对一些常用 API 进行了简单封装以简化使用，同时保留了所有原版属性。适合官方党享用。
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://brickyang.github.io/tags/MongoDB/"/>
    
      <category term="Egg.js" scheme="http://brickyang.github.io/tags/Egg-js/"/>
    
  </entry>
  
  <entry>
    <title>在 CentOS 7 上安装 Docker</title>
    <link href="http://brickyang.github.io/2017/04/12/%E5%9C%A8-CentOS-7-%E4%B8%8A%E5%AE%89%E8%A3%85-Docker-CE/"/>
    <id>http://brickyang.github.io/2017/04/12/在-CentOS-7-上安装-Docker-CE/</id>
    <published>2017-04-12T07:48:19.000Z</published>
    <updated>2019-01-06T09:50:14.464Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录在 CentOS 7 服务器上安装 Docker CE 的过程。Docker CE 是社区版，即免费版。Docker EE 是企业版，即收费版。</p><p><strong>Docker CE 和 EE 版的安装过程不尽相同，本过程仅适用于 CE 版。</strong></p><h2 id="系统要求"><a href="#系统要求" class="headerlink" title="系统要求"></a>系统要求</h2><p>需要 CentOS 7 64-bit。</p><h2 id="卸载旧版本"><a href="#卸载旧版本" class="headerlink" title="卸载旧版本"></a>卸载旧版本</h2><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">sudo</span> yum remove docker docker-<span class="meta">common</span> container-<span class="keyword">selinux </span>docker-<span class="keyword">selinux </span>docker-engine</span><br></pre></td></tr></table></figure><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>有两种方法安装 Docker，这里使用最常用的仓库安装方法。</p><h3 id="建立仓库"><a href="#建立仓库" class="headerlink" title="建立仓库"></a>建立仓库</h3><ol><li>安装 <code>yum-utils</code></li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> -y yum-utils</span><br></pre></td></tr></table></figure><ol start="2"><li>建立仓库</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --<span class="built_in">add</span>-repo http<span class="variable">s:</span>//download.docker.<span class="keyword">com</span>/linux/centos/docker-<span class="keyword">ce</span>.repo</span><br></pre></td></tr></table></figure><h3 id="安装和使用"><a href="#安装和使用" class="headerlink" title="安装和使用"></a>安装和使用</h3><ol><li>更新 <code>yum</code> 包索引</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo yum makecache fast</span></span><br></pre></td></tr></table></figure><ol start="2"><li>安装最新版 Docker（<strong>如需安装指定版本请跳过此步</strong>）</li></ol><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> docker-ce</span><br></pre></td></tr></table></figure><ol start="3"><li>安装指定版本 Docker</li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum <span class="keyword">install</span> docker-ce-&lt;<span class="keyword">VERSION</span>&gt;</span><br></pre></td></tr></table></figure><blockquote><p>建议在生产服务器上总是安装指定版本 Docker。先使用 <code>yum list</code> 命令列出所有版本。</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; yum <span class="keyword">list</span> docker-ce.x86_64  --showduplicates |<span class="keyword">sort</span> -<span class="built_in">r</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><blockquote><p>这个命令安版本号排序列出 Docker CE 的二进制包。</p></blockquote><ol start="4"><li>启动 Docker</li></ol><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure><h3 id="升级-Docker"><a href="#升级-Docker" class="headerlink" title="升级 Docker"></a>升级 Docker</h3><p>如果希望升级 Docker，首先运行 <code>sudo yum makecache fast</code>，然后按照以上步骤重新选择新版本安装。</p><hr><ul><li><a href="https://docs.docker.com/engine/installation/linux/centos/#install-docker" target="_blank" rel="noopener">Get Docker for CentOS</a></li></ul>]]></content>
    
    <summary type="html">
    
      记录在 CentOS 7 服务器上安装 Docker CE 的过程。
    
    </summary>
    
    
      <category term="CentOS" scheme="http://brickyang.github.io/tags/CentOS/"/>
    
      <category term="Docker" scheme="http://brickyang.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>使用 mongorestore 恢复 MongoDB 备份</title>
    <link href="http://brickyang.github.io/2017/04/11/%E4%BD%BF%E7%94%A8-mongorestore-%E6%81%A2%E5%A4%8D-MongoDB-%E5%A4%87%E4%BB%BD/"/>
    <id>http://brickyang.github.io/2017/04/11/使用-mongorestore-恢复-MongoDB-备份/</id>
    <published>2017-04-11T10:37:03.000Z</published>
    <updated>2017-12-21T04:41:39.110Z</updated>
    
    <content type="html"><![CDATA[<p>上一篇<a href="https://brickyang.github.io/2017/03/02/Linux-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD-MongoDB/">《Linux 自动定时备份 MongoDB》</a>文章中说了如何使用 <code>mongodump</code> 命令备份 MongoDB 数据库。这里说明一下如何使用 <code>mongorestore</code> 命令恢复备份。</p><p><code>mongodump</code> 和 <code>mongorestore</code> 是一对命令，分别用于备份和恢复数据。</p><p><code>mongorestore</code> 命令默认将 <code>/dump</code> 文件夹（同时也是 <code>mongodump</code> 的默认备份文件夹）下的所有数据恢复到相应的数据库中，也接受很多选项控制备份操作。</p><p>我们最常用一个的操作需求是：</p><blockquote><p>将指定的备份文件恢复到指定数据库的指定文档</p></blockquote><p>其对应的命令是</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongorestore -d <span class="tag">&lt;<span class="name">DATABASE</span>&gt;</span> -c <span class="tag">&lt;<span class="name">COLLECTION</span>&gt;</span> <span class="tag">&lt;<span class="name">PATH</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>PATH</code> 就是要恢复的数据文件夹或文件，用于恢复整个数据库或指定恢复一个列的数据。</p><hr><ul><li><a href="https://docs.mongodb.com/manual/reference/program/mongorestore/" target="_blank" rel="noopener">mongorestore</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文介绍使用 mongorestore 命令恢复 MongoDB 数据库备份文件。
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://brickyang.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>如何用源生的 React， Webpack，ES6 来使用 Ant Design 组件库？</title>
    <link href="http://brickyang.github.io/2017/03/17/%E5%A6%82%E4%BD%95%E7%94%A8%E6%BA%90%E7%94%9F%E7%9A%84-React%EF%BC%8C-Webpack%EF%BC%8CES6-%E6%9D%A5%E4%BD%BF%E7%94%A8-AantDdesign-%E7%BB%84%E4%BB%B6%E5%BA%93%EF%BC%9F/"/>
    <id>http://brickyang.github.io/2017/03/17/如何用源生的-React，-Webpack，ES6-来使用-AantDdesign-组件库？/</id>
    <published>2017-03-17T09:28:40.000Z</published>
    <updated>2017-11-30T08:41:30.905Z</updated>
    
    <content type="html"><![CDATA[<p>本文是在知乎同名问题下的回答，在这里也记录一下。</p><p><strong>Link：</strong> <a href="https://www.zhihu.com/question/45088537/answer/152124079" target="_blank" rel="noopener">知乎原回答</a>，<a href="https://github.com/brickyang/antd-demo" target="_blank" rel="noopener">GitHub demo</a></p><p><strong>以下是在知乎的回答</strong></p><p>最近刚好开始尝试 Ant Design。之前我用过 Bootstrap、Semantic UI 和 Material Design Lite。和这些库相比 antd 的确是有自己的优势的。</p><p>针对题主的问题，我可以分享点自己的经验。</p><p>GitHub 的 demo 代码：<a href="https://github.com/brickyang/antd-demo" target="_blank" rel="noopener">antd-demo</a></p><p>这个 demo 是我从实际项目中摘出来的。用了 React Router、Webpack 和 Babel。其中 Webpack 用了 <code>assets-webpack-plugin</code> 和 <code>extract-text-webpack-plugin</code> 两个插件。</p><p>其实在实际项目中还用了 CSSModule 和 postcss，这里为了简化就去掉了。</p><p>另外还用了 <code>webpack-dev-server</code> 和 <code>react-hot-loader</code>，都是开发必不可少的，所以就留着了。</p><p><img src="https://pic4.zhimg.com/v2-47b5384132978e73140ada66b71d48db_r.png" alt=""></p><p>这是文件结构：</p><ul><li><code>/build</code>：Webpack 构建的 js 和 css 文件</li><li><code>/config</code>：应用的配置文件，包括 webpack.config 和 webpack.config.dev 的</li><li><code>/src</code>：源代码</li><li><code>/src/components</code>：用于其他页面的 React 组件</li><li><code>/src/Dashboard</code>：应用的 Dashboard 页</li><li><code>/src/Login</code>：应用的 Login 页</li><li><code>/src/router</code>：React Router 实现的路由</li><li><code>/src/index.jsx</code>：前端入口页面</li><li><code>/src/server.js</code>：一个简单的 Node 服务器</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下载下来之后运行 <code>npm start</code> 。在浏览器中访问 <code>localhost:3000</code> 即可。</p><h2 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h2><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">"start": "npm run babel-w &amp; npm run dev-webpack &amp; npm run server",</span><br><span class="line">"dev-webpack": "node webpack-dev-server.js",</span><br><span class="line">"server": "NODE_ENV=development nodemon dist/server.js"</span><br></pre></td></tr></table></figure><p><code>npm start</code> 做了两件事：</p><ol><li>启动 <code>webpack-dev-server</code>。Webpack 构建出临时文件，并由 <code>webpack-dev-server</code> 提供（localhost:8080/build）。通过插件实现了动态加载和文件分离。</li><li>启动 Node 服务器，提供访问服务。</li></ol><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> path = <span class="built_in">require</span>(<span class="string">'path'</span>);</span><br><span class="line"><span class="keyword">const</span> webpack = <span class="built_in">require</span>(<span class="string">'webpack'</span>);</span><br><span class="line"><span class="keyword">const</span> assetsPlugin = <span class="built_in">require</span>(<span class="string">'assets-webpack-plugin'</span>);</span><br><span class="line"><span class="keyword">const</span> extractTextPlugin = <span class="built_in">require</span>(<span class="string">'extract-text-webpack-plugin'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  entry: <span class="string">'./index.jsx'</span>,</span><br><span class="line">  context: path.resolve(__dirname, <span class="string">'../src'</span>),</span><br><span class="line">  output: &#123;</span><br><span class="line">    filename: <span class="string">'[name].[hash].js'</span>,</span><br><span class="line">    hashDigestLength: <span class="number">7</span>,</span><br><span class="line">    path: path.resolve(__dirname, <span class="string">'../build'</span>),</span><br><span class="line">    publicPath:  <span class="string">'localhost:3000/build/'</span></span><br><span class="line">  &#125;,</span><br><span class="line">  resolve: &#123;</span><br><span class="line">    extensions: [<span class="string">'.js'</span>, <span class="string">'.jsx'</span>, <span class="string">'css'</span>]</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="built_in">module</span>: &#123;</span><br><span class="line">    rules: [</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.jsx?$/</span>,</span><br><span class="line">loader: <span class="string">'babel-loader'</span>,</span><br><span class="line">exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">use: extractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: <span class="string">'css-loader'</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        exclude: <span class="regexp">/node_modules/</span></span><br><span class="line">      &#125;,</span><br><span class="line">      &#123;</span><br><span class="line">        test: <span class="regexp">/\.css$/</span>,</span><br><span class="line">        use: extractTextPlugin.extract(&#123;</span><br><span class="line">          fallback: <span class="string">'style-loader'</span>,</span><br><span class="line">          use: <span class="string">'css-loader'</span>,</span><br><span class="line">        &#125;),</span><br><span class="line">        include: path.resolve(__dirname, <span class="string">'../node_modules/antd/lib/'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br><span class="line">  plugins: [</span><br><span class="line">    <span class="keyword">new</span> assetsPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'assets.json'</span>,</span><br><span class="line">    path: <span class="string">'build'</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> extractTextPlugin(&#123;</span><br><span class="line">    filename: <span class="string">'[name].[hash].css'</span>,</span><br><span class="line">    ignoreOrder: <span class="literal">true</span></span><br><span class="line">  &#125;),</span><br><span class="line">  <span class="keyword">new</span> webpack.optimize.UglifyJsPlugin(&#123;</span><br><span class="line">    test: <span class="regexp">/(\.jsx|\.js)$/</span>,</span><br><span class="line">    minimize: <span class="literal">true</span>,</span><br><span class="line">  &#125;)],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是 Webpack 2 的配置文件（和 Webpack 1 有不同）。注意这个是用来构建正式文件的，即 <code>webpack.config.js</code>。开发环境中使用的是 <code>webpack.config.dev.js</code>。二者大同小异，主要是开发环境增加了 <code>react-hot-loader</code>，实现了前端热更新。</p><h2 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h2><p>如果你只关注前端的话，那么 Babel 是使用 <code>babel-loader</code> 在 Webpack 构建时起作用的，不需要自己手动转换。如果你同时还关注后端，其实自从 Node 7.6 支持箭头函数之后，主要的 ES2015 语法都源生支持了，除了 <code>import/export</code>，不一定非得用 Babel。</p><p>如果发现哪里没摘干净或者写错了，欢迎在 issue 指出。</p>]]></content>
    
    <summary type="html">
    
      想上手蚂蚁金服的 Ant Design 组件库，却发现官方教程里都是用自己的一套构建方式，很想了解如何去以常规的 Webpack 上手写页面，以及如何理解组件库的内部机制?
    
    </summary>
    
    
      <category term="React" scheme="http://brickyang.github.io/tags/React/"/>
    
      <category term="Ant Design" scheme="http://brickyang.github.io/tags/Ant-Design/"/>
    
      <category term="Webpack" scheme="http://brickyang.github.io/tags/Webpack/"/>
    
      <category term="Babel" scheme="http://brickyang.github.io/tags/Babel/"/>
    
  </entry>
  
  <entry>
    <title>Docker 中如何设置 container 的时区</title>
    <link href="http://brickyang.github.io/2017/03/16/Docker%20%E4%B8%AD%E5%A6%82%E4%BD%95%E8%AE%BE%E7%BD%AE%20container%20%E7%9A%84%E6%97%B6%E5%8C%BA/"/>
    <id>http://brickyang.github.io/2017/03/16/Docker 中如何设置 container 的时区/</id>
    <published>2017-03-16T04:52:18.000Z</published>
    <updated>2017-11-30T08:41:30.902Z</updated>
    
    <content type="html"><![CDATA[<p>最近在使用 Docker 时发现 container 中的时区是 UTC。这是因为我的基础镜像是官方的 <code>node:7.6</code> 。Docker Store 上的官方镜像基本上都默认是 UTC 时区，需要我们手动设置一下。</p><h2 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h2><p>如果你使用 Dockerfile 制作自己的镜像，那么只需要在 Dockerfile 中加入下面两句就可以了：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; /etc/timezone</span></span><br><span class="line"><span class="bash">RUN dpkg-reconfigure -f noninteractive tzdata</span></span><br></pre></td></tr></table></figure><blockquote><p><code>echo &quot;Asia/Shanghai&quot; &gt; /etc/timezone</code> 和 <code>dpkg-reconfigure -f noninteractive tzdata</code> 是 Ubuntu 修改时区的命令。Docker 默认使用 Ubuntu 系统。如果你的自定义镜像使用的是其他发行版，那么这里的命令也要改变。</p></blockquote><p>在制作镜像过程中可以看到以下输出：</p><figure class="highlight vbscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Current <span class="keyword">default</span> <span class="built_in">time</span> zone: <span class="comment">'Asia/Shanghai'</span></span><br><span class="line">Local <span class="built_in">time</span> <span class="keyword">is</span> <span class="built_in">now</span>:      Thu Mar <span class="number">16</span> <span class="number">12</span>:<span class="number">51</span>:<span class="number">35</span> CST <span class="number">2017.</span></span><br><span class="line">Universal <span class="built_in">Time</span> <span class="keyword">is</span> <span class="built_in">now</span>:  Thu Mar <span class="number">16</span> <span class="number">04</span>:<span class="number">51</span>:<span class="number">35</span> UTC <span class="number">2017.</span></span><br></pre></td></tr></table></figure><p>修改成功。以后这个镜像生成的 container 就都是北京时间了。</p><h2 id="同步主机时区"><a href="#同步主机时区" class="headerlink" title="同步主机时区"></a>同步主机时区</h2><p>利用 <code>volume</code> 可以在启动一个 container 时指定使用主机的时区文件，就可以把 container 的时区与主机同步：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -v <span class="regexp">/etc/</span><span class="string">localtime:</span><span class="regexp">/etc/</span>localtime &lt;<span class="string">IMAGE:</span>TAG&gt;</span><br></pre></td></tr></table></figure><p>这种方法的好处是不会修改镜像，适合需要在不同时区主机上运行的场景。</p><h2 id="运行中的-container"><a href="#运行中的-container" class="headerlink" title="运行中的 container"></a>运行中的 container</h2><p>如果你不想新建镜像或者重启 container，那么也可以直接进入 container 修改。执行：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it &lt;CONTAINER <span class="built_in">NAME</span>&gt; bash</span><br></pre></td></tr></table></figure><p>进入 container 之后执行：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">echo</span> <span class="string">"Asia/Shanghai"</span> &gt; <span class="string">/etc/timezone</span></span><br><span class="line">dpkg-reconfigure -f noninteractive tzdata</span><br></pre></td></tr></table></figure><blockquote><p>仍然需要注意不同发行版命令的差别。</p></blockquote><p>这里和 Docker 有关的主要是如何进入 container，进去之后该怎么操作就怎么操作。</p>]]></content>
    
    <summary type="html">
    
      使用官方镜像时，默认时区往往是 UTC，和国内有8个小时时差，所以需要我们手动修改时区。
    
    </summary>
    
    
      <category term="Docker" scheme="http://brickyang.github.io/tags/Docker/"/>
    
      <category term="Linux" scheme="http://brickyang.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>利用 Docker 运行 MongoDB</title>
    <link href="http://brickyang.github.io/2017/03/15/%E5%88%A9%E7%94%A8-Docker-%E8%BF%90%E8%A1%8C-MongoDB/"/>
    <id>http://brickyang.github.io/2017/03/15/利用-Docker-运行-MongoDB/</id>
    <published>2017-03-15T06:10:17.000Z</published>
    <updated>2017-11-30T08:41:30.904Z</updated>
    
    <content type="html"><![CDATA[<p>在服务器上通过 Docker 运行 MongoDB，可以省略本地安装数据库的步骤，并且日常的运维和使用与本地安装基本没有区别。</p><h2 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h2><p>我们将使用官方的 <code>mongo:3.4</code> 镜像（image），并将 <code>27017</code> 端口映射到主机端口，同时利用 Docker Volume 将数据库文件保存在主机上而非容器（container）中。</p><p>通过端口映射，可以直接连接主机的 <code>27017</code> 端口。比如如果你在使用一些 GUI 管理工具，不会有任何影响。</p><p>通过 Volume 将文件保存在主机，与容器分离，数据的使用与容器无关，所有针对数据的操作（比如备份、恢复）都不受影响。</p><h2 id="运行-mongo"><a href="#运行-mongo" class="headerlink" title="运行 mongo"></a>运行 mongo</h2><p>这里我们直接使用官方的 mong 镜像。</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --<span class="keyword">name</span> &lt;YOUR-<span class="keyword">NAME</span>&gt; -p <span class="number">27017</span>:<span class="number">27017</span> -v /<span class="keyword">data</span>/db:/<span class="keyword">data</span>/db -d mongo:<span class="number">3.4</span> --auth</span><br></pre></td></tr></table></figure><p><code>—name</code> 指定库的名字，如果不指定会使用一串随机字符串。</p><p><code>-p 27017:27017</code> 官方的镜像已经暴露了 <code>27017</code> 端口，我们将它映射到主机的端口上。如果你不使用默认端口，将 <code>:</code> 前面的数字改成自定义端口。</p><p><code>-v /data/db:/data/db</code> 冒号前面的是主机上的文件路径，将它挂载到库中的文件夹下，实际对文件的读写就会在主机文件上操作。</p><p><code>-d</code> 在后台运行。</p><p><code>mongo:3.4</code> 指定镜像版本，默认是 <code>latest</code> 。建议总是自己指定版本。</p><p><code>—auth</code> 以 <code>auth</code> 模式运行 mongo。</p><p>然后执行一下 <code>docker ps</code> 确认一下库已经正常运行起来。</p><h2 id="新建管理员"><a href="#新建管理员" class="headerlink" title="新建管理员"></a>新建管理员</h2><p>现在我们需要进入 mongo shell 操作：</p><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it &lt;YOUR-NAME&gt; mongo admin</span><br><span class="line">&gt; db.createUser(&#123; <span class="string">user:</span> <span class="string">'&lt;USER&gt;'</span>, <span class="string">pwd:</span> <span class="string">'&lt;PASSWORD&gt;'</span>, <span class="string">roles:</span> [ &#123; <span class="string">role:</span> <span class="string">'userAdminAnyDatabase'</span>, <span class="string">db:</span> <span class="string">'admin'</span> &#125; ]&#125;);</span><br><span class="line">Successfully added <span class="string">user:</span> &#123;</span><br><span class="line">    <span class="string">"user"</span> : <span class="string">"&lt;USER&gt;"</span>,</span><br><span class="line">    <span class="string">"roles"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="string">"role"</span> : <span class="string">"userAdminAnyDatabase"</span>,</span><br><span class="line">            <span class="string">"db"</span> : <span class="string">"admin"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以后想以管理员身份登入 mongo shell 就可以运行：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker exec -it <span class="tag">&lt;<span class="name">YOUR-NAME</span>&gt;</span> mongo -u <span class="tag">&lt;<span class="name">USER</span>&gt;</span> -p <span class="tag">&lt;<span class="name">PASSWORD</span>&gt;</span> --authenticationDatabase admin</span><br></pre></td></tr></table></figure><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>现在我们就可以像本地安装的 mong 一样操作了。如果误删了数据库管理员，可以停掉正在运行的库，然后去掉 <code>—auth</code> 重新运行一个新库，登录进去新建用户即可。</p>]]></content>
    
    <summary type="html">
    
      通过 Docker 运行 MongoDB，避免了复杂的本地安装和维护过程，同时可以像本地安装一样自由操作。
    
    </summary>
    
    
      <category term="Docker" scheme="http://brickyang.github.io/tags/Docker/"/>
    
      <category term="MongoDB" scheme="http://brickyang.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>Linux 自动定时备份 MongoDB</title>
    <link href="http://brickyang.github.io/2017/03/02/Linux-%E8%87%AA%E5%8A%A8%E5%A4%87%E4%BB%BD-MongoDB/"/>
    <id>http://brickyang.github.io/2017/03/02/Linux-自动备份-MongoDB/</id>
    <published>2017-03-02T10:01:52.000Z</published>
    <updated>2017-12-21T04:41:39.109Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍在 Linux 系统下，使用 <code>mongodump</code> 命令自动定时备份数据库的方法。</p><h2 id="mongodump"><a href="#mongodump" class="headerlink" title="mongodump"></a>mongodump</h2><p><code>mongodump</code> 是 MongoDB 提供的一个工具，用于备份数据库，配合使用 <code>mongorestore</code> 恢复工具使用。这套工具适合小型应用或开发环境。</p><p>运行 <code>mongodump</code> 和 <code>mongorestore</code> 时需要读取正在运行的数据库实例，因此会影响数据库性能。一方面是运行时需要占用系统资源，另一方面，运行这两个命令时数据库会强制通过内存读取所有数据，可能导致读取的不常用数据覆盖常用数据，从而影响数据库日常运行的性能。</p><p><em>2.2及以上版本的 <code>mongodump</code> 数据格式与低版本<strong>不兼容</strong>，因此请勿使用高版本工具备份低版本数据。</em></p><p><code>mongodump</code> 不会备份 <code>local</code> 数据库。</p><p>直接运行 <code>mongodump</code> 命令，默认备份本地运行在27017端口下的 MongoDB 实例中的所有数据库（<code>local</code> 除外），并在当前目录下生成 <code>dump/</code> 路径存放备份文件。</p><p>你也可以使用以下命令指定备份的数据库位置、端口、输出文件位置、备份数据库和文档：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mongodump <span class="params">--host</span> mongodb.example.net <span class="params">--port</span> 27017 <span class="params">--out</span> <span class="string">/data/backup/</span> <span class="params">--db</span> test <span class="params">--collection</span> myCollection</span><br></pre></td></tr></table></figure><h2 id="命令脚本"><a href="#命令脚本" class="headerlink" title="命令脚本"></a>命令脚本</h2><p>首先我们要创建一个执行备份工作的脚本。在 <code>~/crontab/</code> 下新建一个 <code>.sh</code> 文件：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> -<span class="keyword">p</span> ~/crontab</span><br><span class="line"><span class="keyword">vi</span> ~/crontab/mongod_bak.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure><p>写入以下内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">DUMP=mongodump</span><br><span class="line">OUT_DIR=/data/backup/mongod/tmp   // 备份文件临时目录</span><br><span class="line">TAR_DIR=/data/backup/mongod       // 备份文件正式目录</span><br><span class="line">DATE=`date +%Y_%m_%d_%H_%M_%S`    // 备份文件将以备份时间保存</span><br><span class="line">DB_USER=&lt;USER&gt;                    // 数据库操作员</span><br><span class="line">DB_PASS=&lt;PASSWORD&gt;                // 数据库操作员密码</span><br><span class="line">DAYS=14                           // 保留最新14天的备份</span><br><span class="line">TAR_BAK=<span class="string">"mongod_bak_<span class="variable">$DATE</span>.tar.gz"</span> // 备份文件命名格式</span><br><span class="line"><span class="built_in">cd</span> <span class="variable">$OUT_DIR</span>                       // 创建文件夹</span><br><span class="line">rm -rf <span class="variable">$OUT_DIR</span>/*                 // 清空临时目录</span><br><span class="line">mkdir -p <span class="variable">$OUT_DIR</span>/<span class="variable">$DATE</span>           // 创建本次备份文件夹</span><br><span class="line"><span class="variable">$DUMP</span> -u <span class="variable">$DB_USER</span> -p <span class="variable">$DB_PASS</span> -o <span class="variable">$OUT_DIR</span>/<span class="variable">$DATE</span>  // 执行备份命令</span><br><span class="line">tar -zcvf <span class="variable">$TAR_DIR</span>/<span class="variable">$TAR_BAK</span> <span class="variable">$OUT_DIR</span>/<span class="variable">$DATE</span>       // 将备份文件打包放入正式目录</span><br><span class="line">find <span class="variable">$TAR_DIR</span>/ -mtime +<span class="variable">$DAYS</span> -delete             // 删除14天前的旧备份</span><br></pre></td></tr></table></figure><p>这个脚本完成了备份、打包、删除一定时间之前旧备份的工作。注意其中的 <code>user</code> 需要具有对希望备份的数据库具有 <code>find</code> 操作权限。</p><p>保存好脚本后别忘了将它设为可执行：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ~<span class="regexp">/crontab/m</span>ongod_bak.sh</span><br></pre></td></tr></table></figure><p>现在你可以试着执行一下 <code>./mongod_bak.sh</code>，就会在备份文件夹中看到打包好的备份数据了。</p><h2 id="自动运行"><a href="#自动运行" class="headerlink" title="自动运行"></a>自动运行</h2><p>备份脚本写好之后，就需要让它自动运行。直接使用 Linux 的 <code>crontab</code> 命令即可：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>crontab</span><br></pre></td></tr></table></figure><p>在底部添加：</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span><span class="number">2</span> * * * root ~/crontab/mongod_bak.sh</span><br></pre></td></tr></table></figure><p>这一行表示在每天凌晨02:00以 root 身份运行备份数据库的脚本。然后重启 crond 使其生效：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/systemctl restart  crond.service</span><br><span class="line">chkconfig crond on    <span class="comment">// 设为开机启动</span></span><br></pre></td></tr></table></figure><p>至此，一个自动运行的备份脚本就设置好了。以后每天凌晨02:00都会有一份新鲜的备份文件放在指定目录中，并且会自动删除14天前的旧备份。</p><h2 id="恢复备份"><a href="#恢复备份" class="headerlink" title="恢复备份"></a>恢复备份</h2><p><a href="https://brickyang.github.io/2017/04/11/%E4%BD%BF%E7%94%A8-mongorestore-%E6%81%A2%E5%A4%8D-MongoDB-%E5%A4%87%E4%BB%BD/">使用 mongorestore 恢复 MongoDB 备份</a></p><hr><ul><li><a href="https://docs.mongodb.com/manual/tutorial/backup-and-restore-tools/" target="_blank" rel="noopener">Back Up and Restore with MongoDB Tools</a></li><li><a href="https://zh.wikipedia.org/zh-hans/Cron" target="_blank" rel="noopener">Cron - Wikipedia</a></li></ul>]]></content>
    
    <summary type="html">
    
      本文介绍在 Linux 系统下，使用 mongodump 命令自动定时备份数据库的方法。
    
    </summary>
    
    
      <category term="MongoDB" scheme="http://brickyang.github.io/tags/MongoDB/"/>
    
  </entry>
  
  <entry>
    <title>CentOS 7 安装 shadowsocks 客户端</title>
    <link href="http://brickyang.github.io/2017/01/14/CentOS-7-%E5%AE%89%E8%A3%85-Shadowsocks-%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
    <id>http://brickyang.github.io/2017/01/14/CentOS-7-安装-Shadowsocks-客户端/</id>
    <published>2017-01-14T10:01:52.000Z</published>
    <updated>2017-11-30T08:41:30.902Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近由于在阿里云从 GitHub 拖代码非常困难，因此萌生了在服务器上使用 shadowsocks 的念头。</p><p>本文记录了我在 CentOS 7 上成功安装运行 shadowsocks 客户端的过程。</p><p><strong>本文的过程我已在本地 CentOS 上成功运行，尚未在阿里云实测。</strong></p><p><strong>给新手：</strong>这里介绍的是安装 shadowsocks <strong>客户端</strong>的过程，也就是让服务器能正常访问 GitHub 的方法。你需要已经有一个 shadowsocks 服务端。</p><p>一般网上找到的「CentOS 安装 shadowsocks」文章多数都是讲安装服务端的。</p><h2 id="安装-pip"><a href="#安装-pip" class="headerlink" title="安装 pip"></a>安装 pip</h2><p>Pip 是 Python 的包管理工具，这里我们用 pip 安装 shadowsocks。</p><p>有些文章会介绍用 <code>yum install -y pip</code> 安装，我用的是官方一个最小化的 CentOS，没有这个包，所以手动安装。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl <span class="string">"https://bootstrap.pypa.io/get-pip.py"</span> -<span class="keyword">o</span> <span class="string">"get-pip.py"</span></span><br><span class="line"><span class="keyword">python</span> <span class="built_in">get</span>-pip.<span class="keyword">py</span></span><br></pre></td></tr></table></figure><h2 id="Shadowsocks-客户端"><a href="#Shadowsocks-客户端" class="headerlink" title="Shadowsocks 客户端"></a>Shadowsocks 客户端</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pip <span class="keyword">install</span> <span class="comment">--upgrade pip</span></span><br><span class="line">pip <span class="keyword">install</span> shadowsocks</span><br></pre></td></tr></table></figure><h3 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h3><p>新建配置文件：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/etc/</span>shadowsocks.json</span><br></pre></td></tr></table></figure><p>填写以下内容</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"server"</span>:<span class="string">"x.x.x.x"</span>,             #你的 ss 服务器 ip</span><br><span class="line">  <span class="string">"server_port"</span>:0,                #你的 ss 服务器端口</span><br><span class="line">  <span class="string">"local_address"</span>: <span class="string">"127.0.0.1"</span>,   #本地ip</span><br><span class="line">  <span class="string">"local_port"</span>:0,                 #本地端口</span><br><span class="line">  <span class="string">"password"</span>:<span class="string">"password"</span>,          #连接 ss 密码</span><br><span class="line">  <span class="string">"timeout"</span>:300,                  #等待超时</span><br><span class="line">  <span class="string">"method"</span>:<span class="string">"aes-256-cfb"</span>,         #加密方式</span><br><span class="line">  <span class="string">"workers"</span>: 1                    #工作线程数</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="启动"><a href="#启动" class="headerlink" title="启动"></a>启动</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup sslocal -c <span class="meta-keyword">/etc/</span>shadowsocks.json <span class="meta-keyword">/dev/</span>null <span class="number">2</span>&gt;<span class="variable">&amp;1</span> &amp;</span><br><span class="line">echo <span class="string">" nohup sslocal -c /etc/shadowsocks.json /dev/null 2&gt;&amp;1 &amp;"</span> <span class="meta-keyword">/etc/</span>rc.local   <span class="meta">#设置自启动</span></span><br></pre></td></tr></table></figure><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>运行 <code>curl --socks5 127.0.0.1:1985 http://httpbin.org/ip</code>，如果返回你的 ss 服务器 ip 则测试成功：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"origin"</span>: <span class="string">"x.x.x.x"</span>       #你的 ss 服务器 ip</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Privoxy"><a href="#Privoxy" class="headerlink" title="Privoxy"></a>Privoxy</h2><p>Shadowsocks 是一个 socket5 服务，我们需要使用 Privoxy 把流量转到 http／https 上。</p><p>###下载安装文件</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">wget http:<span class="comment">//www.privoxy.org/sf-download-mirror/Sources/3.0.26%20%28stable%29/privoxy-3.0.26-stable-src.tar.gz</span></span><br><span class="line">tar -zxvf privoxy-<span class="number">3.0</span>.<span class="number">26</span>-stable-src<span class="selector-class">.tar</span><span class="selector-class">.gz</span></span><br><span class="line">cd privoxy-<span class="number">3.0</span>.<span class="number">26</span>-stable</span><br></pre></td></tr></table></figure><p>privoxy-3.0.26-stable 是目前最新的稳定版，建议在下载前去 <a href="https://www.privoxy.org/sf-download-mirror/Sources/" target="_blank" rel="noopener">Privoxy 官网下载页</a> 检查一下版本。</p><h3 id="新建用户"><a href="#新建用户" class="headerlink" title="新建用户"></a>新建用户</h3><p>Privoxy 强烈不建议使用 root 用户运行，所以我们使用 <code>useradd privoxy</code> 新建一个用户.</p><h3 id="安装-1"><a href="#安装-1" class="headerlink" title="安装"></a>安装</h3><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">autoheader <span class="meta">&amp;&amp; autoconf</span></span><br><span class="line">./configure</span><br><span class="line">make <span class="meta">&amp;&amp; make install</span></span><br></pre></td></tr></table></figure><h3 id="配置-1"><a href="#配置-1" class="headerlink" title="配置"></a>配置</h3><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="regexp">/usr/</span>local<span class="regexp">/etc/</span>privoxy<span class="regexp">/config</span></span><br></pre></td></tr></table></figure><p>找到以下两句，确保没有注释掉</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen-address <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">8118</span>   # <span class="number">8118</span> 是默认端口，不用改，下面会用到</span><br><span class="line">forward-socks5t / <span class="number">127.0</span><span class="meta">.0</span><span class="meta">.1</span>:<span class="number">0</span> . # 这里的端口写 shadowsocks 的本地端口（注意最后那个 . 不要漏了）</span><br></pre></td></tr></table></figure><h3 id="启动-1"><a href="#启动-1" class="headerlink" title="启动"></a>启动</h3><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">privoxy --<span class="keyword">user</span> <span class="title">privoxy</span> /usr/local/etc/privoxy/config</span><br></pre></td></tr></table></figure><h2 id="配置-etc-profile"><a href="#配置-etc-profile" class="headerlink" title="配置 /etc/profile"></a>配置 /etc/profile</h2><p>编辑：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">vi</span> /etc/<span class="keyword">profile</span></span><br></pre></td></tr></table></figure><p>添加下面两句：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">http_proxy</span>=http://127.0.0.1:8118       #这里的端口和上面 privoxy 中的保持一致</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">https_proxy</span>=http://127.0.0.1:8118</span><br></pre></td></tr></table></figure><p>运行以下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">source</span> <span class="regexp">/etc/</span>profile</span><br></pre></td></tr></table></figure><p>测试生效：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl www<span class="selector-class">.google</span><span class="selector-class">.com</span></span><br></pre></td></tr></table></figure><p>返回一大堆 HTML 则说明 shadowsocks 正常工作了。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>如果不能访问，请重启机器，依次打开 shadowsocks 和 privoxy 再测试.</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nohup sslocal -c <span class="meta-keyword">/etc/</span>shadowsocks.json <span class="meta-keyword">/dev/</span>null <span class="number">2</span>&gt;<span class="variable">&amp;1</span> &amp;</span><br><span class="line">privoxy --user privoxy <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/etc/</span>privoxy/config</span><br></pre></td></tr></table></figure><p>如果不需要用代理了，记得把 <code>/etc/profile</code> 里的配置注释掉，不然会一直走代理流量。</p><hr><ul><li><a href="https://www.privoxy.org/" target="_blank" rel="noopener">Privoxy - Home Page</a></li><li><a href="https://zh.wikipedia.org/wiki/Shadowsocks" target="_blank" rel="noopener">Shadowsocks - Wikis</a></li></ul>]]></content>
    
    <summary type="html">
    
      使用国内服务器，无论用 npm 还是 GitHub 都不太顺畅。Npm 可以用 cnpm 代替，GitHub 就没办法了。用了 shadowsocks，这个问题就完美解决了。
    
    </summary>
    
    
      <category term="CentOS" scheme="http://brickyang.github.io/tags/CentOS/"/>
    
      <category term="Shadowsocks" scheme="http://brickyang.github.io/tags/Shadowsocks/"/>
    
  </entry>
  
</feed>
